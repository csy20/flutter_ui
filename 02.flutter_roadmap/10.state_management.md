# State Management Solutions in Flutter

State management is like managing the **memory of your app** - keeping track of what the user has done, what data is displayed, and how different parts of your app communicate with each other.

## What is State Management? (Simple Explanation)

Imagine your Flutter app is like a **smart house** with multiple rooms:

```
üè† SMART HOUSE (Your Flutter App)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üì± Living Room (Home Screen)                               ‚îÇ
‚îÇ  ‚Ä¢ Shows: "Temperature: 22¬∞C"                              ‚îÇ
‚îÇ  ‚Ä¢ Shows: "Lights: On"                                     ‚îÇ
‚îÇ  ‚Ä¢ Shows: "Music: Playing"                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  üéµ Music Room (Music Screen)                               ‚îÇ
‚îÇ  ‚Ä¢ Shows: Current song                                     ‚îÇ
‚îÇ  ‚Ä¢ Play/Pause button                                       ‚îÇ
‚îÇ  ‚Ä¢ Volume slider                                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  üí° Control Room (Settings Screen)                         ‚îÇ
‚îÇ  ‚Ä¢ Temperature controls                                    ‚îÇ
‚îÇ  ‚Ä¢ Light switches                                          ‚îÇ
‚îÇ  ‚Ä¢ Music settings                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üß† CENTRAL BRAIN (State Management)
When you change temperature in Control Room,
Living Room should update automatically!
```

**Without State Management:**
```dart
// ‚ùå BAD: Each screen manages its own data
class LivingRoomScreen extends StatefulWidget {
  int temperature = 22; // Only this screen knows temperature
}

class ControlRoomScreen extends StatefulWidget {
  int temperature = 20; // Different temperature! üò±
}
// Problem: Screens don't know about each other's changes!
```

**With State Management:**
```dart
// ‚úÖ GOOD: Shared brain manages all data
class HouseState {
  int temperature = 22;    // Single source of truth
  bool lightsOn = true;
  String currentSong = "Happy Song";
}
// All screens get data from the same place!
```

## Types of State

### 1. Local State (Widget-specific)
```dart
// üîí LOCAL STATE: Only one widget cares about this
class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int _counter = 0; // Only this widget needs to know
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Counter: $_counter'),
        ElevatedButton(
          onPressed: () => setState(() => _counter++),
          child: Text('Increment'),
        ),
      ],
    );
  }
}
```

### 2. Global State (App-wide)
```dart
// üåç GLOBAL STATE: Multiple widgets need this data
class User {
  final String name;
  final String email;
  final bool isLoggedIn;
  
  User({required this.name, required this.email, required this.isLoggedIn});
}

// This user data is needed in:
// - AppBar (show user name)
// - Profile screen (show all details)
// - Settings screen (logout button)
// - Multiple other screens
```

## State Management Solutions Comparison

| Solution | Complexity | Learning Curve | Performance | Popularity |
|----------|------------|----------------|-------------|------------|
| **Provider** | üü¢ Simple | üü¢ Easy | üü° Good | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **BLoC/Cubit** | üî¥ Complex | üî¥ Hard | üü¢ Excellent | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Riverpod** | üü° Medium | üü° Medium | üü¢ Excellent | ‚≠ê‚≠ê‚≠ê |
| **GetX** | üü¢ Simple | üü¢ Easy | üü¢ Excellent | ‚≠ê‚≠ê‚≠ê‚≠ê |

---

## 1. Provider - The Simple Choice

**Provider is like a bulletin board** - you post information and anyone can read it.

### Basic Provider Example

```dart
// üìã STEP 1: Create a data model
class ShoppingCart extends ChangeNotifier {
  List<String> _items = [];
  
  // Getter to read items
  List<String> get items => List.unmodifiable(_items);
  int get itemCount => _items.length;
  double get totalPrice => _items.length * 10.0; // $10 per item
  
  // Method to add item
  void addItem(String item) {
    _items.add(item);
    notifyListeners(); // Tell all widgets: "Hey, I changed!"
  }
  
  // Method to remove item
  void removeItem(String item) {
    _items.remove(item);
    notifyListeners(); // Tell all widgets about the change
  }
  
  // Method to clear cart
  void clearCart() {
    _items.clear();
    notifyListeners();
  }
}

// üì± STEP 2: Provide the data to your app
class ShoppingApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => ShoppingCart(), // Create the shopping cart
      child: MaterialApp(
        title: 'Shopping App',
        home: HomeScreen(),
      ),
    );
  }
}

// üìñ STEP 3: Read data in widgets
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Shopping App'),
        actions: [
          // This widget listens to cart changes
          Consumer<ShoppingCart>(
            builder: (context, cart, child) {
              return Padding(
                padding: EdgeInsets.all(16),
                child: Center(
                  child: Text(
                    '${cart.itemCount}', // Shows current count
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                ),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // Add items section
          _AddItemsSection(),
          
          // Cart summary
          _CartSummary(),
          
          // Items list
          Expanded(child: _ItemsList()),
        ],
      ),
    );
  }
}

class _AddItemsSection extends StatelessWidget {
  final List<String> availableItems = [
    'Apple', 'Banana', 'Orange', 'Milk', 'Bread'
  ];
  
  @override
  Widget build(BuildContext context) {
    return Card(
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Add Items to Cart',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 12),
            Wrap(
              spacing: 8,
              children: availableItems.map((item) {
                return ElevatedButton(
                  onPressed: () {
                    // Access the cart and add item
                    context.read<ShoppingCart>().addItem(item);
                    
                    // Show feedback
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Added $item to cart')),
                    );
                  },
                  child: Text(item),
                );
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }
}

class _CartSummary extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<ShoppingCart>(
      builder: (context, cart, child) {
        return Card(
          margin: EdgeInsets.symmetric(horizontal: 16),
          color: Colors.blue[50],
          child: Padding(
            padding: EdgeInsets.all(16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Cart Summary',
                      style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                    ),
                    Text('Items: ${cart.itemCount}'),
                    Text('Total: \$${cart.totalPrice.toStringAsFixed(2)}'),
                  ],
                ),
                if (cart.itemCount > 0)
                  ElevatedButton(
                    onPressed: () => cart.clearCart(),
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
                    child: Text('Clear Cart'),
                  ),
              ],
            ),
          ),
        );
      },
    );
  }
}

class _ItemsList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<ShoppingCart>(
      builder: (context, cart, child) {
        if (cart.items.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.shopping_cart, size: 64, color: Colors.grey),
                SizedBox(height: 16),
                Text(
                  'Your cart is empty',
                  style: TextStyle(fontSize: 18, color: Colors.grey),
                ),
              ],
            ),
          );
        }
        
        return ListView.builder(
          padding: EdgeInsets.all(16),
          itemCount: cart.items.length,
          itemBuilder: (context, index) {
            final item = cart.items[index];
            return Card(
              child: ListTile(
                leading: Icon(Icons.shopping_bag),
                title: Text(item),
                subtitle: Text('\$10.00'),
                trailing: IconButton(
                  icon: Icon(Icons.remove, color: Colors.red),
                  onPressed: () => cart.removeItem(item),
                ),
              ),
            );
          },
        );
      },
    );
  }
}
```

### Multiple Providers Example

```dart
// Multiple data models
class UserProfile extends ChangeNotifier {
  String _name = '';
  String _email = '';
  bool _isLoggedIn = false;
  
  String get name => _name;
  String get email => _email;
  bool get isLoggedIn => _isLoggedIn;
  
  void login(String name, String email) {
    _name = name;
    _email = email;
    _isLoggedIn = true;
    notifyListeners();
  }
  
  void logout() {
    _name = '';
    _email = '';
    _isLoggedIn = false;
    notifyListeners();
  }
}

class AppSettings extends ChangeNotifier {
  bool _darkMode = false;
  String _language = 'English';
  
  bool get darkMode => _darkMode;
  String get language => _language;
  
  void toggleDarkMode() {
    _darkMode = !_darkMode;
    notifyListeners();
  }
  
  void setLanguage(String language) {
    _language = language;
    notifyListeners();
  }
}

// Using multiple providers
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => ShoppingCart()),
        ChangeNotifierProvider(create: (context) => UserProfile()),
        ChangeNotifierProvider(create: (context) => AppSettings()),
      ],
      child: Consumer<AppSettings>(
        builder: (context, settings, child) {
          return MaterialApp(
            title: 'Multi Provider App',
            theme: settings.darkMode ? ThemeData.dark() : ThemeData.light(),
            home: MainScreen(),
          );
        },
      ),
    );
  }
}
```

---

## 2. BLoC/Cubit - The Powerful Choice

**BLoC is like a professional secretary** - receives requests, processes them, and gives back results.

### Cubit Example (Simpler BLoC)

```dart
// üìä STEP 1: Define states
abstract class CounterState {}

class CounterInitial extends CounterState {}

class CounterLoading extends CounterState {}

class CounterValue extends CounterState {
  final int value;
  CounterValue(this.value);
}

class CounterError extends CounterState {
  final String message;
  CounterError(this.message);
}

// üß† STEP 2: Create Cubit (Business Logic)
class CounterCubit extends Cubit<CounterState> {
  CounterCubit() : super(CounterInitial());
  
  int _currentValue = 0;
  
  // Actions the UI can trigger
  void increment() {
    emit(CounterLoading()); // Show loading
    
    // Simulate some processing time
    Future.delayed(Duration(milliseconds: 500), () {
      _currentValue++;
      emit(CounterValue(_currentValue)); // Emit new value
    });
  }
  
  void decrement() {
    if (_currentValue > 0) {
      emit(CounterLoading());
      Future.delayed(Duration(milliseconds: 500), () {
        _currentValue--;
        emit(CounterValue(_currentValue));
      });
    } else {
      emit(CounterError('Cannot go below zero!'));
      // Return to current value after showing error
      Future.delayed(Duration(seconds: 2), () {
        emit(CounterValue(_currentValue));
      });
    }
  }
  
  void reset() {
    _currentValue = 0;
    emit(CounterValue(_currentValue));
  }
}

// üì± STEP 3: Use in UI
class CounterApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Cubit Counter',
      home: BlocProvider(
        create: (context) => CounterCubit(),
        child: CounterScreen(),
      ),
    );
  }
}

class CounterScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Cubit Counter')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Listen to state changes
            BlocBuilder<CounterCubit, CounterState>(
              builder: (context, state) {
                if (state is CounterLoading) {
                  return Column(
                    children: [
                      CircularProgressIndicator(),
                      SizedBox(height: 16),
                      Text('Processing...'),
                    ],
                  );
                }
                
                if (state is CounterError) {
                  return Column(
                    children: [
                      Icon(Icons.error, color: Colors.red, size: 48),
                      SizedBox(height: 16),
                      Text(
                        state.message,
                        style: TextStyle(color: Colors.red, fontSize: 18),
                      ),
                    ],
                  );
                }
                
                if (state is CounterValue) {
                  return Column(
                    children: [
                      Text(
                        'Counter Value',
                        style: TextStyle(fontSize: 18),
                      ),
                      SizedBox(height: 16),
                      Text(
                        '${state.value}',
                        style: TextStyle(fontSize: 48, fontWeight: FontWeight.bold),
                      ),
                    ],
                  );
                }
                
                // Initial state
                return Text(
                  'Press a button to start',
                  style: TextStyle(fontSize: 18),
                );
              },
            ),
            
            SizedBox(height: 32),
            
            // Action buttons
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton(
                  onPressed: () => context.read<CounterCubit>().decrement(),
                  child: Text('-'),
                ),
                ElevatedButton(
                  onPressed: () => context.read<CounterCubit>().reset(),
                  child: Text('Reset'),
                ),
                ElevatedButton(
                  onPressed: () => context.read<CounterCubit>().increment(),
                  child: Text('+'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

### Full BLoC Example (Todo App)

```dart
// üìä STEP 1: Define Events (What can happen)
abstract class TodoEvent {}

class LoadTodos extends TodoEvent {}

class AddTodo extends TodoEvent {
  final String title;
  AddTodo(this.title);
}

class ToggleTodo extends TodoEvent {
  final int index;
  ToggleTodo(this.index);
}

class DeleteTodo extends TodoEvent {
  final int index;
  DeleteTodo(this.index);
}

// üìä STEP 2: Define States (What the UI can look like)
abstract class TodoState {}

class TodoInitial extends TodoState {}

class TodoLoading extends TodoState {}

class TodoLoaded extends TodoState {
  final List<Todo> todos;
  TodoLoaded(this.todos);
}

class TodoError extends TodoState {
  final String message;
  TodoError(this.message);
}

// üìä STEP 3: Todo Model
class Todo {
  final String title;
  final bool isCompleted;
  
  Todo({required this.title, this.isCompleted = false});
  
  Todo copyWith({String? title, bool? isCompleted}) {
    return Todo(
      title: title ?? this.title,
      isCompleted: isCompleted ?? this.isCompleted,
    );
  }
}

// üß† STEP 4: Create BLoC
class TodoBloc extends Bloc<TodoEvent, TodoState> {
  List<Todo> _todos = [];
  
  TodoBloc() : super(TodoInitial()) {
    // Handle different events
    on<LoadTodos>(_onLoadTodos);
    on<AddTodo>(_onAddTodo);
    on<ToggleTodo>(_onToggleTodo);
    on<DeleteTodo>(_onDeleteTodo);
  }
  
  Future<void> _onLoadTodos(LoadTodos event, Emitter<TodoState> emit) async {
    emit(TodoLoading());
    
    try {
      // Simulate loading from API
      await Future.delayed(Duration(seconds: 1));
      
      // Initial todos
      _todos = [
        Todo(title: 'Learn Flutter'),
        Todo(title: 'Build an app'),
        Todo(title: 'Deploy to store'),
      ];
      
      emit(TodoLoaded(_todos));
    } catch (e) {
      emit(TodoError('Failed to load todos'));
    }
  }
  
  Future<void> _onAddTodo(AddTodo event, Emitter<TodoState> emit) async {
    if (state is TodoLoaded) {
      try {
        final newTodo = Todo(title: event.title);
        _todos.insert(0, newTodo); // Add to beginning
        emit(TodoLoaded(List.from(_todos)));
      } catch (e) {
        emit(TodoError('Failed to add todo'));
      }
    }
  }
  
  Future<void> _onToggleTodo(ToggleTodo event, Emitter<TodoState> emit) async {
    if (state is TodoLoaded && event.index < _todos.length) {
      try {
        final todo = _todos[event.index];
        _todos[event.index] = todo.copyWith(isCompleted: !todo.isCompleted);
        emit(TodoLoaded(List.from(_todos)));
      } catch (e) {
        emit(TodoError('Failed to update todo'));
      }
    }
  }
  
  Future<void> _onDeleteTodo(DeleteTodo event, Emitter<TodoState> emit) async {
    if (state is TodoLoaded && event.index < _todos.length) {
      try {
        _todos.removeAt(event.index);
        emit(TodoLoaded(List.from(_todos)));
      } catch (e) {
        emit(TodoError('Failed to delete todo'));
      }
    }
  }
}

// üì± STEP 5: Use in UI
class TodoBlocApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Todo BLoC',
      home: BlocProvider(
        create: (context) => TodoBloc()..add(LoadTodos()),
        child: TodoScreen(),
      ),
    );
  }
}

class TodoScreen extends StatelessWidget {
  final TextEditingController _controller = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Todo BLoC')),
      body: Column(
        children: [
          // Add todo section
          Padding(
            padding: EdgeInsets.all(16),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _controller,
                    decoration: InputDecoration(
                      hintText: 'Enter todo...',
                      border: OutlineInputBorder(),
                    ),
                  ),
                ),
                SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    if (_controller.text.isNotEmpty) {
                      context.read<TodoBloc>().add(AddTodo(_controller.text));
                      _controller.clear();
                    }
                  },
                  child: Text('Add'),
                ),
              ],
            ),
          ),
          
          // Todo list
          Expanded(
            child: BlocBuilder<TodoBloc, TodoState>(
              builder: (context, state) {
                if (state is TodoLoading) {
                  return Center(child: CircularProgressIndicator());
                }
                
                if (state is TodoError) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.error, size: 64, color: Colors.red),
                        SizedBox(height: 16),
                        Text(state.message),
                        ElevatedButton(
                          onPressed: () => context.read<TodoBloc>().add(LoadTodos()),
                          child: Text('Retry'),
                        ),
                      ],
                    ),
                  );
                }
                
                if (state is TodoLoaded) {
                  if (state.todos.isEmpty) {
                    return Center(
                      child: Text('No todos yet. Add one above!'),
                    );
                  }
                  
                  return ListView.builder(
                    itemCount: state.todos.length,
                    itemBuilder: (context, index) {
                      final todo = state.todos[index];
                      return Card(
                        margin: EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                        child: ListTile(
                          leading: IconButton(
                            icon: Icon(
                              todo.isCompleted 
                                  ? Icons.check_circle 
                                  : Icons.radio_button_unchecked,
                              color: todo.isCompleted ? Colors.green : null,
                            ),
                            onPressed: () {
                              context.read<TodoBloc>().add(ToggleTodo(index));
                            },
                          ),
                          title: Text(
                            todo.title,
                            style: TextStyle(
                              decoration: todo.isCompleted 
                                  ? TextDecoration.lineThrough 
                                  : null,
                            ),
                          ),
                          trailing: IconButton(
                            icon: Icon(Icons.delete, color: Colors.red),
                            onPressed: () {
                              context.read<TodoBloc>().add(DeleteTodo(index));
                            },
                          ),
                        ),
                      );
                    },
                  );
                }
                
                return Center(child: Text('Press + to load todos'));
              },
            ),
          ),
        ],
      ),
    );
  }
}
```

---

## 3. Riverpod - The Modern Choice

**Riverpod is like a smart assistant** - automatically manages dependencies and updates efficiently.

### Basic Riverpod Example

```dart
// üìä STEP 1: Create providers
final counterProvider = StateProvider<int>((ref) => 0);

final doubledCounterProvider = Provider<int>((ref) {
  final count = ref.watch(counterProvider);
  return count * 2;
});

final isEvenProvider = Provider<bool>((ref) {
  final count = ref.watch(counterProvider);
  return count % 2 == 0;
});

// üì± STEP 2: Use in app
class RiverpodApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ProviderScope( // Wrap app with ProviderScope
      child: MaterialApp(
        title: 'Riverpod Counter',
        home: CounterScreen(),
      ),
    );
  }
}

class CounterScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch providers
    final count = ref.watch(counterProvider);
    final doubled = ref.watch(doubledCounterProvider);
    final isEven = ref.watch(isEvenProvider);
    
    return Scaffold(
      appBar: AppBar(title: Text('Riverpod Counter')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Counter: $count',
              style: TextStyle(fontSize: 24),
            ),
            SizedBox(height: 16),
            Text(
              'Doubled: $doubled',
              style: TextStyle(fontSize: 20, color: Colors.blue),
            ),
            SizedBox(height: 16),
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: isEven ? Colors.green : Colors.orange,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                isEven ? 'Even Number' : 'Odd Number',
                style: TextStyle(color: Colors.white, fontSize: 16),
              ),
            ),
            SizedBox(height: 32),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton(
                  onPressed: () {
                    ref.read(counterProvider.notifier).state--;
                  },
                  child: Text('- Decrement'),
                ),
                ElevatedButton(
                  onPressed: () {
                    ref.read(counterProvider.notifier).state = 0;
                  },
                  child: Text('Reset'),
                ),
                ElevatedButton(
                  onPressed: () {
                    ref.read(counterProvider.notifier).state++;
                  },
                  child: Text('+ Increment'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

### Advanced Riverpod Example (Todo with API)

```dart
// üìä STEP 1: Create models and services
class Todo {
  final int id;
  final String title;
  final bool completed;
  
  Todo({required this.id, required this.title, required this.completed});
  
  factory Todo.fromJson(Map<String, dynamic> json) {
    return Todo(
      id: json['id'],
      title: json['title'],
      completed: json['completed'],
    );
  }
  
  Todo copyWith({int? id, String? title, bool? completed}) {
    return Todo(
      id: id ?? this.id,
      title: title ?? this.title,
      completed: completed ?? this.completed,
    );
  }
}

class TodoService {
  Future<List<Todo>> fetchTodos() async {
    await Future.delayed(Duration(seconds: 2)); // Simulate network delay
    
    // Simulate API response
    return [
      Todo(id: 1, title: 'Learn Riverpod', completed: false),
      Todo(id: 2, title: 'Build awesome app', completed: false),
      Todo(id: 3, title: 'Ship to production', completed: true),
    ];
  }
  
  Future<Todo> addTodo(String title) async {
    await Future.delayed(Duration(milliseconds: 500));
    return Todo(
      id: DateTime.now().millisecondsSinceEpoch,
      title: title,
      completed: false,
    );
  }
}

// üìä STEP 2: Create providers
final todoServiceProvider = Provider<TodoService>((ref) => TodoService());

final todosProvider = FutureProvider<List<Todo>>((ref) async {
  final todoService = ref.read(todoServiceProvider);
  return todoService.fetchTodos();
});

final todoListProvider = StateNotifierProvider<TodoListNotifier, List<Todo>>((ref) {
  return TodoListNotifier();
});

// StateNotifier for managing todo list
class TodoListNotifier extends StateNotifier<List<Todo>> {
  TodoListNotifier() : super([]);
  
  void setTodos(List<Todo> todos) {
    state = todos;
  }
  
  void addTodo(Todo todo) {
    state = [...state, todo];
  }
  
  void toggleTodo(int id) {
    state = [
      for (final todo in state)
        if (todo.id == id)
          todo.copyWith(completed: !todo.completed)
        else
          todo,
    ];
  }
  
  void removeTodo(int id) {
    state = state.where((todo) => todo.id != id).toList();
  }
}

// Computed providers
final completedTodosProvider = Provider<List<Todo>>((ref) {
  final todos = ref.watch(todoListProvider);
  return todos.where((todo) => todo.completed).toList();
});

final pendingTodosProvider = Provider<List<Todo>>((ref) {
  final todos = ref.watch(todoListProvider);
  return todos.where((todo) => !todo.completed).toList();
});

final todoStatsProvider = Provider<Map<String, int>>((ref) {
  final todos = ref.watch(todoListProvider);
  final completed = ref.watch(completedTodosProvider);
  final pending = ref.watch(pendingTodosProvider);
  
  return {
    'total': todos.length,
    'completed': completed.length,
    'pending': pending.length,
  };
});

// üì± STEP 3: UI Implementation
class RiverpodTodoApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ProviderScope(
      child: MaterialApp(
        title: 'Riverpod Todo',
        home: TodoScreen(),
      ),
    );
  }
}

class TodoScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final todosAsync = ref.watch(todosProvider);
    
    return Scaffold(
      appBar: AppBar(
        title: Text('Riverpod Todo'),
        actions: [
          Consumer(
            builder: (context, ref, child) {
              final stats = ref.watch(todoStatsProvider);
              return Padding(
                padding: EdgeInsets.all(16),
                child: Center(
                  child: Text('${stats['pending']}/${stats['total']}'),
                ),
              );
            },
          ),
        ],
      ),
      body: todosAsync.when(
        loading: () => Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error, size: 64, color: Colors.red),
              SizedBox(height: 16),
              Text('Error: $error'),
              ElevatedButton(
                onPressed: () => ref.refresh(todosProvider),
                child: Text('Retry'),
              ),
            ],
          ),
        ),
        data: (todos) {
          // Initialize todo list when data loads
          WidgetsBinding.instance.addPostFrameCallback((_) {
            ref.read(todoListProvider.notifier).setTodos(todos);
          });
          
          return Column(
            children: [
              _TodoStats(),
              _AddTodoSection(),
              Expanded(child: _TodoList()),
            ],
          );
        },
      ),
    );
  }
}

class _TodoStats extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final stats = ref.watch(todoStatsProvider);
    
    return Card(
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _StatItem('Total', stats['total']!, Colors.blue),
            _StatItem('Pending', stats['pending']!, Colors.orange),
            _StatItem('Completed', stats['completed']!, Colors.green),
          ],
        ),
      ),
    );
  }
}

class _StatItem extends StatelessWidget {
  final String label;
  final int count;
  final Color color;
  
  const _StatItem(this.label, this.count, this.color);
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(
          count.toString(),
          style: TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        Text(label),
      ],
    );
  }
}

class _AddTodoSection extends ConsumerStatefulWidget {
  @override
  _AddTodoSectionState createState() => _AddTodoSectionState();
}

class _AddTodoSectionState extends ConsumerState<_AddTodoSection> {
  final _controller = TextEditingController();
  bool _isAdding = false;
  
  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.all(16),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _controller,
              decoration: InputDecoration(
                hintText: 'Add new todo...',
                border: OutlineInputBorder(),
              ),
            ),
          ),
          SizedBox(width: 8),
          ElevatedButton(
            onPressed: _isAdding ? null : _addTodo,
            child: _isAdding 
                ? SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : Text('Add'),
          ),
        ],
      ),
    );
  }
  
  Future<void> _addTodo() async {
    if (_controller.text.isEmpty) return;
    
    setState(() => _isAdding = true);
    
    try {
      final todoService = ref.read(todoServiceProvider);
      final newTodo = await todoService.addTodo(_controller.text);
      ref.read(todoListProvider.notifier).addTodo(newTodo);
      _controller.clear();
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to add todo: $e')),
      );
    } finally {
      setState(() => _isAdding = false);
    }
  }
  
  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}

class _TodoList extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final todos = ref.watch(todoListProvider);
    
    if (todos.isEmpty) {
      return Center(
        child: Text('No todos yet. Add one above!'),
      );
    }
    
    return ListView.builder(
      padding: EdgeInsets.symmetric(horizontal: 16),
      itemCount: todos.length,
      itemBuilder: (context, index) {
        final todo = todos[index];
        return Card(
          margin: EdgeInsets.only(bottom: 8),
          child: ListTile(
            leading: IconButton(
              icon: Icon(
                todo.completed ? Icons.check_circle : Icons.radio_button_unchecked,
                color: todo.completed ? Colors.green : null,
              ),
              onPressed: () {
                ref.read(todoListProvider.notifier).toggleTodo(todo.id);
              },
            ),
            title: Text(
              todo.title,
              style: TextStyle(
                decoration: todo.completed ? TextDecoration.lineThrough : null,
              ),
            ),
            trailing: IconButton(
              icon: Icon(Icons.delete, color: Colors.red),
              onPressed: () {
                ref.read(todoListProvider.notifier).removeTodo(todo.id);
              },
            ),
          ),
        );
      },
    );
  }
}
```

---

## 4. GetX - The All-in-One Choice

**GetX is like a Swiss Army knife** - does everything: state management, navigation, dependency injection.

### Basic GetX Example

```dart
// üìä STEP 1: Create controller
class CounterController extends GetxController {
  // Observable variable
  final count = 0.obs;
  final isEven = true.obs;
  final message = ''.obs;
  
  // Computed properties
  int get doubled => count.value * 2;
  String get countText => 'Count: ${count.value}';
  
  // Actions
  void increment() {
    count.value++;
    _updateEven();
    message.value = 'Incremented to ${count.value}';
    
    // Auto-clear message
    Future.delayed(Duration(seconds: 2), () {
      message.value = '';
    });
  }
  
  void decrement() {
    if (count.value > 0) {
      count.value--;
      _updateEven();
      message.value = 'Decremented to ${count.value}';
    } else {
      Get.snackbar(
        'Warning',
        'Cannot go below zero!',
        backgroundColor: Colors.orange,
        colorText: Colors.white,
      );
    }
    
    Future.delayed(Duration(seconds: 2), () {
      message.value = '';
    });
  }
  
  void reset() {
    count.value = 0;
    _updateEven();
    message.value = 'Counter reset';
    
    Future.delayed(Duration(seconds: 2), () {
      message.value = '';
    });
  }
  
  void _updateEven() {
    isEven.value = count.value % 2 == 0;
  }
  
  @override
  void onInit() {
    super.onInit();
    print('CounterController initialized');
  }
  
  @override
  void onClose() {
    print('CounterController disposed');
    super.onClose();
  }
}

// üì± STEP 2: Use in UI
class GetXApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Use GetMaterialApp instead of MaterialApp
      title: 'GetX Counter',
      home: CounterScreen(),
    );
  }
}

class CounterScreen extends StatelessWidget {
  // Initialize controller
  final CounterController controller = Get.put(CounterController());
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX Counter')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Watch specific value
            Obx(() => Text(
              controller.countText,
              style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
            )),
            
            SizedBox(height: 16),
            
            // Watch computed property
            Obx(() => Text(
              'Doubled: ${controller.doubled}',
              style: TextStyle(fontSize: 20, color: Colors.blue),
            )),
            
            SizedBox(height: 16),
            
            // Watch another observable
            Obx(() => Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: controller.isEven.value ? Colors.green : Colors.orange,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text(
                controller.isEven.value ? 'Even Number' : 'Odd Number',
                style: TextStyle(color: Colors.white, fontSize: 16),
              ),
            )),
            
            SizedBox(height: 16),
            
            // Message display
            Obx(() => AnimatedContainer(
              duration: Duration(milliseconds: 300),
              height: controller.message.value.isEmpty ? 0 : 40,
              child: controller.message.value.isEmpty
                  ? SizedBox.shrink()
                  : Container(
                      padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                      decoration: BoxDecoration(
                        color: Colors.blue[100],
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        controller.message.value,
                        style: TextStyle(color: Colors.blue[800]),
                      ),
                    ),
            )),
            
            SizedBox(height: 32),
            
            // Action buttons
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                ElevatedButton(
                  onPressed: controller.decrement,
                  child: Text('- Decrement'),
                ),
                ElevatedButton(
                  onPressed: controller.reset,
                  child: Text('Reset'),
                ),
                ElevatedButton(
                  onPressed: controller.increment,
                  child: Text('+ Increment'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

### Advanced GetX Example (Todo with Navigation)

```dart
// üìä STEP 1: Models
class Todo {
  final String id;
  final String title;
  final String description;
  final bool isCompleted;
  final DateTime createdAt;
  
  Todo({
    required this.id,
    required this.title,
    required this.description,
    required this.isCompleted,
    required this.createdAt,
  });
  
  Todo copyWith({
    String? id,
    String? title,
    String? description,
    bool? isCompleted,
    DateTime? createdAt,
  }) {
    return Todo(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      isCompleted: isCompleted ?? this.isCompleted,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}

// üìä STEP 2: Service
class TodoService extends GetxService {
  Future<List<Todo>> fetchTodos() async {
    await Future.delayed(Duration(seconds: 2));
    return [
      Todo(
        id: '1',
        title: 'Learn GetX',
        description: 'Master GetX state management',
        isCompleted: false,
        createdAt: DateTime.now().subtract(Duration(days: 1)),
      ),
      Todo(
        id: '2',
        title: 'Build Todo App',
        description: 'Create a complete todo application',
        isCompleted: true,
        createdAt: DateTime.now().subtract(Duration(hours: 2)),
      ),
    ];
  }
  
  Future<void> saveTodo(Todo todo) async {
    await Future.delayed(Duration(milliseconds: 500));
    // Simulate save
  }
  
  Future<void> deleteTodo(String id) async {
    await Future.delayed(Duration(milliseconds: 300));
    // Simulate delete
  }
}

// üìä STEP 3: Controller
class TodoController extends GetxController {
  final TodoService _todoService = Get.find<TodoService>();
  
  // Observable variables
  final todos = <Todo>[].obs;
  final isLoading = false.obs;
  final filter = 'all'.obs; // 'all', 'pending', 'completed'
  
  // Computed properties
  List<Todo> get filteredTodos {
    switch (filter.value) {
      case 'pending':
        return todos.where((todo) => !todo.isCompleted).toList();
      case 'completed':
        return todos.where((todo) => todo.isCompleted).toList();
      default:
        return todos.toList();
    }
  }
  
  int get totalTodos => todos.length;
  int get completedTodos => todos.where((todo) => todo.isCompleted).length;
  int get pendingTodos => todos.where((todo) => !todo.isCompleted).length;
  
  @override
  void onInit() {
    super.onInit();
    loadTodos();
  }
  
  Future<void> loadTodos() async {
    try {
      isLoading.value = true;
      final fetchedTodos = await _todoService.fetchTodos();
      todos.assignAll(fetchedTodos);
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to load todos: $e',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }
  
  Future<void> addTodo(String title, String description) async {
    if (title.trim().isEmpty) {
      Get.snackbar(
        'Validation Error',
        'Title cannot be empty',
        backgroundColor: Colors.orange,
        colorText: Colors.white,
      );
      return;
    }
    
    try {
      final newTodo = Todo(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        title: title.trim(),
        description: description.trim(),
        isCompleted: false,
        createdAt: DateTime.now(),
      );
      
      // Optimistic update
      todos.insert(0, newTodo);
      
      await _todoService.saveTodo(newTodo);
      
      Get.snackbar(
        'Success',
        'Todo added successfully',
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } catch (e) {
      // Revert optimistic update
      todos.removeWhere((todo) => todo.title == title);
      
      Get.snackbar(
        'Error',
        'Failed to add todo: $e',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }
  
  Future<void> toggleTodo(String id) async {
    try {
      final index = todos.indexWhere((todo) => todo.id == id);
      if (index != -1) {
        final todo = todos[index];
        final updatedTodo = todo.copyWith(isCompleted: !todo.isCompleted);
        
        // Optimistic update
        todos[index] = updatedTodo;
        
        await _todoService.saveTodo(updatedTodo);
      }
    } catch (e) {
      // Revert on error
      loadTodos();
      
      Get.snackbar(
        'Error',
        'Failed to update todo: $e',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }
  
  Future<void> deleteTodo(String id) async {
    try {
      final todoToDelete = todos.firstWhere((todo) => todo.id == id);
      
      // Optimistic delete
      todos.removeWhere((todo) => todo.id == id);
      
      await _todoService.deleteTodo(id);
      
      Get.snackbar(
        'Success',
        'Todo deleted',
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } catch (e) {
      // Revert on error
      loadTodos();
      
      Get.snackbar(
        'Error',
        'Failed to delete todo: $e',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }
  
  void setFilter(String newFilter) {
    filter.value = newFilter;
  }
  
  void goToAddTodo() {
    Get.to(() => AddTodoScreen());
  }
  
  void goToTodoDetail(Todo todo) {
    Get.to(() => TodoDetailScreen(todo: todo));
  }
}

// üì± STEP 4: Screens
class GetXTodoApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Initialize services
    Get.put(TodoService());
    
    return GetMaterialApp(
      title: 'GetX Todo',
      home: TodoListScreen(),
      getPages: [
        GetPage(name: '/todos', page: () => TodoListScreen()),
        GetPage(name: '/add-todo', page: () => AddTodoScreen()),
      ],
    );
  }
}

class TodoListScreen extends StatelessWidget {
  final TodoController controller = Get.put(TodoController());
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('GetX Todo'),
        actions: [
          Obx(() => Padding(
            padding: EdgeInsets.all(16),
            child: Center(
              child: Text('${controller.pendingTodos}/${controller.totalTodos}'),
            ),
          )),
        ],
      ),
      body: Column(
        children: [
          _buildStatsCard(),
          _buildFilterChips(),
          Expanded(child: _buildTodoList()),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: controller.goToAddTodo,
        child: Icon(Icons.add),
      ),
    );
  }
  
  Widget _buildStatsCard() {
    return Obx(() => Card(
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStatItem('Total', controller.totalTodos, Colors.blue),
            _buildStatItem('Pending', controller.pendingTodos, Colors.orange),
            _buildStatItem('Done', controller.completedTodos, Colors.green),
          ],
        ),
      ),
    ));
  }
  
  Widget _buildStatItem(String label, int count, Color color) {
    return Column(
      children: [
        Text(
          count.toString(),
          style: TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
        Text(label),
      ],
    );
  }
  
  Widget _buildFilterChips() {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: 16),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          Obx(() => FilterChip(
            label: Text('All'),
            selected: controller.filter.value == 'all',
            onSelected: (_) => controller.setFilter('all'),
          )),
          Obx(() => FilterChip(
            label: Text('Pending'),
            selected: controller.filter.value == 'pending',
            onSelected: (_) => controller.setFilter('pending'),
          )),
          Obx(() => FilterChip(
            label: Text('Completed'),
            selected: controller.filter.value == 'completed',
            onSelected: (_) => controller.setFilter('completed'),
          )),
        ],
      ),
    );
  }
  
  Widget _buildTodoList() {
    return Obx(() {
      if (controller.isLoading.value) {
        return Center(child: CircularProgressIndicator());
      }
      
      if (controller.filteredTodos.isEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.inbox, size: 64, color: Colors.grey),
              SizedBox(height: 16),
              Text('No todos found'),
            ],
          ),
        );
      }
      
      return ListView.builder(
        padding: EdgeInsets.all(16),
        itemCount: controller.filteredTodos.length,
        itemBuilder: (context, index) {
          final todo = controller.filteredTodos[index];
          return Card(
            margin: EdgeInsets.only(bottom: 8),
            child: ListTile(
              leading: IconButton(
                icon: Icon(
                  todo.isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,
                  color: todo.isCompleted ? Colors.green : null,
                ),
                onPressed: () => controller.toggleTodo(todo.id),
              ),
              title: Text(
                todo.title,
                style: TextStyle(
                  decoration: todo.isCompleted ? TextDecoration.lineThrough : null,
                ),
              ),
              subtitle: todo.description.isNotEmpty ? Text(todo.description) : null,
              trailing: IconButton(
                icon: Icon(Icons.delete, color: Colors.red),
                onPressed: () => controller.deleteTodo(todo.id),
              ),
              onTap: () => controller.goToTodoDetail(todo),
            ),
          );
        },
      );
    });
  }
}

class AddTodoScreen extends StatelessWidget {
  final TextEditingController titleController = TextEditingController();
  final TextEditingController descriptionController = TextEditingController();
  final TodoController todoController = Get.find<TodoController>();
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Add Todo'),
        actions: [
          TextButton(
            onPressed: _saveTodo,
            child: Text('Save', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
      body: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          children: [
            TextField(
              controller: titleController,
              decoration: InputDecoration(
                labelText: 'Title',
                border: OutlineInputBorder(),
              ),
            ),
            SizedBox(height: 16),
            TextField(
              controller: descriptionController,
              decoration: InputDecoration(
                labelText: 'Description',
                border: OutlineInputBorder(),
              ),
              maxLines: 3,
            ),
            SizedBox(height: 24),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: _saveTodo,
                child: Text('Add Todo'),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  void _saveTodo() async {
    await todoController.addTodo(
      titleController.text,
      descriptionController.text,
    );
    Get.back(); // Navigate back
  }
}

class TodoDetailScreen extends StatelessWidget {
  final Todo todo;
  
  const TodoDetailScreen({required this.todo});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Todo Details')),
      body: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              todo.title,
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            if (todo.description.isNotEmpty) ...[
              Text(
                'Description:',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              SizedBox(height: 8),
              Text(todo.description),
              SizedBox(height: 16),
            ],
            Text(
              'Status: ${todo.isCompleted ? "Completed" : "Pending"}',
              style: TextStyle(
                color: todo.isCompleted ? Colors.green : Colors.orange,
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: 8),
            Text('Created: ${todo.createdAt.toString().split('.')[0]}'),
          ],
        ),
      ),
    );
  }
}
```

## When to Use Which Solution?

### üü¢ **Choose Provider When:**
- You're new to Flutter
- Building simple to medium apps
- Want official Google recommendation
- Need good community support
- Prefer simple, straightforward approach

### üî¥ **Choose BLoC/Cubit When:**
- Building large, complex applications
- Need strict separation between UI and business logic
- Working in a team with complex requirements
- Want maximum testability
- Need predictable state changes

### üü° **Choose Riverpod When:**
- Want modern, type-safe state management
- Need automatic dependency management
- Building medium to large apps
- Want better performance than Provider
- Prefer functional programming approach

### üü¢ **Choose GetX When:**
- Want an all-in-one solution
- Need routing + state management + dependency injection
- Building rapid prototypes
- Want minimal boilerplate code
- Prefer reactive programming

## Summary Comparison

| Feature | Provider | BLoC | Riverpod | GetX |
|---------|----------|------|----------|------|
| **Learning Curve** | Easy | Hard | Medium | Easy |
| **Boilerplate** | Low | High | Medium | Very Low |
| **Performance** | Good | Excellent | Excellent | Excellent |
| **Testing** | Good | Excellent | Excellent | Good |
| **Navigation** | Separate | Separate | Separate | Built-in |
| **DI** | Manual | Manual | Built-in | Built-in |
| **Community** | Large | Large | Growing | Large |
| **Documentation** | Excellent | Excellent | Good | Good |

## Key Takeaways

1. **Start Simple**: Begin with Provider or GetX for learning
2. **Scale Up**: Move to BLoC or Riverpod for complex apps
3. **Team Decisions**: Consider team experience and project requirements
4. **Consistency**: Stick to one solution throughout your project
5. **Testing**: All solutions support testing, but BLoC excels
6. **Performance**: All modern solutions perform well

Choose based on your **project complexity**, **team expertise**, and **specific requirements**. There's no "wrong" choice - each solution has its place in different scenarios!