# Backend & Services in Flutter

Backend & Services are like the **invisible helpers** behind your app - they handle data storage, send notifications, and keep track of what's happening even when users aren't looking.

## What are Backend & Services? (Simple Explanation)

Think of your Flutter app like a **restaurant**:

```
🍽️ RESTAURANT ANALOGY
┌─────────────────────────────────────────────────────────────┐
│  🏪 FRONT (Your Flutter App)                               │
│  • Beautiful dining area                                   │
│  • Customers can see and interact                         │
│  • Order food, see menu                                   │
└─────────────────────────────────────────────────────────────┘
│  🔧 KITCHEN (Backend Services)                             │
│  • Invisible to customers                                 │
│  • Prepares food (processes data)                         │
│  • Stores ingredients (database)                          │
│  • Sends notifications ("Your order is ready!")           │
└─────────────────────────────────────────────────────────────┘
│  📱 NOTIFICATION SYSTEM (Push Notifications)               │
│  • Waiter calls your name                                 │
│  • Text message: "Food ready!"                            │
│  • Works even if you're outside                           │
└─────────────────────────────────────────────────────────────┘
│  📋 MANAGER (Error Handling & Logging)                     │
│  • Watches everything                                     │
│  • Fixes problems quickly                                 │
│  • Keeps records of what happened                         │
└─────────────────────────────────────────────────────────────┘
```

**Key Services:**
- **Push Notifications**: Send messages to users even when app is closed
- **Error Handling**: Catch and fix problems gracefully
- **Logging**: Keep track of what happens in your app

---

## 1. Push Notifications

Push notifications are like **sending a letter to someone's mailbox** - you can reach them even when they're not actively using your app.

### How Push Notifications Work

```
📱 PUSH NOTIFICATION FLOW
┌─────────────────────────────────────────────────────────────┐
│  1. 🏗️ YOUR FLUTTER APP                                    │
│     • Registers for notifications                          │
│     • Gets a unique token (like an address)               │
└─────────────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────────────┐
│  2. ☁️ FIREBASE/BACKEND SERVER                             │
│     • Stores user's token                                 │
│     • Decides when to send notifications                   │
│     • Sends message to Firebase Cloud Messaging (FCM)     │
└─────────────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────────────┐
│  3. 📡 GOOGLE'S FCM SERVICE                                │
│     • Receives your message                               │
│     • Finds the right device                              │
│     • Delivers notification                               │
└─────────────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────────────┐
│  4. 📱 USER'S DEVICE                                       │
│     • Shows notification on screen                        │
│     • Plays sound/vibration                               │
│     • User can tap to open app                            │
└─────────────────────────────────────────────────────────────┘
```

### 1.1 Setting Up Firebase Cloud Messaging (FCM)

```dart
// 📱 STEP 1: Add dependencies to pubspec.yaml
/*
dependencies:
  firebase_core: ^2.24.2
  firebase_messaging: ^14.7.10
  flutter_local_notifications: ^16.3.2
  permission_handler: ^11.3.0
*/

// 📱 STEP 2: Firebase setup and notification service
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:permission_handler/permission_handler.dart';

// 🔧 NOTIFICATION SERVICE CLASS
class NotificationService {
  static final NotificationService _instance = NotificationService._internal();
  factory NotificationService() => _instance;
  NotificationService._internal();
  
  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;
  final FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
  
  String? _fcmToken;
  String? get fcmToken => _fcmToken;
  
  // 🚀 INITIALIZE NOTIFICATIONS
  Future<void> initialize() async {
    print('🔧 Initializing Notification Service...');
    
    try {
      // Request permissions
      await _requestPermissions();
      
      // Configure local notifications
      await _setupLocalNotifications();
      
      // Configure FCM
      await _setupFCM();
      
      // Get FCM token
      await _getFCMToken();
      
      print('✅ Notification Service initialized successfully');
    } catch (e) {
      print('❌ Error initializing notifications: $e');
    }
  }
  
  // 🔐 REQUEST PERMISSIONS
  Future<void> _requestPermissions() async {
    print('🔐 Requesting notification permissions...');
    
    // Request FCM permissions
    NotificationSettings settings = await _firebaseMessaging.requestPermission(
      alert: true,
      announcement: false,
      badge: true,
      carPlay: false,
      criticalAlert: false,
      provisional: false,
      sound: true,
    );
    
    // Request system permissions
    await Permission.notification.request();
    
    print('🔐 Permission status: ${settings.authorizationStatus}');
  }
  
  // 🔧 SETUP LOCAL NOTIFICATIONS
  Future<void> _setupLocalNotifications() async {
    print('🔧 Setting up local notifications...');
    
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosSettings = DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );
    
    const settings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );
    
    await _flutterLocalNotificationsPlugin.initialize(
      settings,
      onDidReceiveNotificationResponse: _onNotificationTapped,
    );
    
    // Create notification channel for Android
    const androidNotificationChannel = AndroidNotificationChannel(
      'high_importance_channel',
      'High Importance Notifications',
      description: 'This channel is used for important notifications.',
      importance: Importance.high,
    );
    
    await _flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<AndroidFlutterLocalNotificationsPlugin>()
        ?.createNotificationChannel(androidNotificationChannel);
  }
  
  // 🔧 SETUP FCM
  Future<void> _setupFCM() async {
    print('🔧 Setting up FCM...');
    
    // Handle foreground messages
    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
    
    // Handle background messages
    FirebaseMessaging.onBackgroundMessage(_handleBackgroundMessage);
    
    // Handle notification opened app
    FirebaseMessaging.onMessageOpenedApp.listen(_handleNotificationOpenedApp);
    
    // Handle initial message (app opened from terminated state)
    RemoteMessage? initialMessage = await _firebaseMessaging.getInitialMessage();
    if (initialMessage != null) {
      _handleNotificationOpenedApp(initialMessage);
    }
  }
  
  // 🎫 GET FCM TOKEN
  Future<void> _getFCMToken() async {
    try {
      _fcmToken = await _firebaseMessaging.getToken();
      print('🎫 FCM Token: $_fcmToken');
      
      // Listen for token refresh
      _firebaseMessaging.onTokenRefresh.listen((newToken) {
        _fcmToken = newToken;
        print('🔄 FCM Token refreshed: $newToken');
        // TODO: Send new token to your server
      });
    } catch (e) {
      print('❌ Error getting FCM token: $e');
    }
  }
  
  // 📱 HANDLE FOREGROUND MESSAGES
  void _handleForegroundMessage(RemoteMessage message) {
    print('📱 Received foreground message: ${message.messageId}');
    
    // Show local notification when app is in foreground
    _showLocalNotification(message);
  }
  
  // 📱 HANDLE NOTIFICATION TAPPED
  void _onNotificationTapped(NotificationResponse response) {
    print('📱 Notification tapped: ${response.payload}');
    
    // TODO: Navigate to specific screen based on payload
    // Navigator.pushNamed(context, '/notification-detail');
  }
  
  // 📱 HANDLE NOTIFICATION OPENED APP
  void _handleNotificationOpenedApp(RemoteMessage message) {
    print('📱 Notification opened app: ${message.messageId}');
    
    // TODO: Navigate to specific screen
    // Example: Navigate to order details, chat screen, etc.
  }
  
  // 🔔 SHOW LOCAL NOTIFICATION
  Future<void> _showLocalNotification(RemoteMessage message) async {
    const androidDetails = AndroidNotificationDetails(
      'high_importance_channel',
      'High Importance Notifications',
      channelDescription: 'This channel is used for important notifications.',
      importance: Importance.high,
      priority: Priority.high,
      showWhen: true,
      icon: '@mipmap/ic_launcher',
    );
    
    const iosDetails = DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
    );
    
    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );
    
    await _flutterLocalNotificationsPlugin.show(
      message.hashCode,
      message.notification?.title ?? 'New Message',
      message.notification?.body ?? 'You have a new notification',
      details,
      payload: message.data.toString(),
    );
  }
  
  // 📤 SEND LOCAL NOTIFICATION (for testing)
  Future<void> sendLocalNotification({
    required String title,
    required String body,
    String? payload,
  }) async {
    const androidDetails = AndroidNotificationDetails(
      'high_importance_channel',
      'High Importance Notifications',
      channelDescription: 'This channel is used for important notifications.',
      importance: Importance.high,
      priority: Priority.high,
      showWhen: true,
    );
    
    const iosDetails = DarwinNotificationDetails();
    
    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );
    
    await _flutterLocalNotificationsPlugin.show(
      DateTime.now().millisecondsSinceEpoch ~/ 1000,
      title,
      body,
      details,
      payload: payload,
    );
  }
  
  // 📤 SCHEDULE NOTIFICATION
  Future<void> scheduleNotification({
    required String title,
    required String body,
    required DateTime scheduledDate,
    String? payload,
  }) async {
    const androidDetails = AndroidNotificationDetails(
      'scheduled_channel',
      'Scheduled Notifications',
      channelDescription: 'This channel is used for scheduled notifications.',
      importance: Importance.high,
      priority: Priority.high,
    );
    
    const iosDetails = DarwinNotificationDetails();
    
    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );
    
    await _flutterLocalNotificationsPlugin.zonedSchedule(
      DateTime.now().millisecondsSinceEpoch ~/ 1000,
      title,
      body,
      tz.TZDateTime.from(scheduledDate, tz.local),
      details,
      payload: payload,
      uiLocalNotificationDateInterpretation:
          UILocalNotificationDateInterpretation.absoluteTime,
    );
  }
}

// 🔙 BACKGROUND MESSAGE HANDLER (must be top-level function)
@pragma('vm:entry-point')
Future<void> _handleBackgroundMessage(RemoteMessage message) async {
  await Firebase.initializeApp();
  print('🔙 Handling background message: ${message.messageId}');
}

// 📱 NOTIFICATION DEMO SCREEN
class NotificationDemoScreen extends StatefulWidget {
  @override
  _NotificationDemoScreenState createState() => _NotificationDemoScreenState();
}

class _NotificationDemoScreenState extends State<NotificationDemoScreen> {
  final NotificationService _notificationService = NotificationService();
  String? _fcmToken;
  
  @override
  void initState() {
    super.initState();
    _initializeNotifications();
  }
  
  Future<void> _initializeNotifications() async {
    await _notificationService.initialize();
    setState(() {
      _fcmToken = _notificationService.fcmToken;
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Push Notifications Demo')),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // FCM Token Display
            Card(
              child: Padding(
                padding: EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'FCM Token',
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                    SizedBox(height: 8),
                    Container(
                      padding: EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.grey[100],
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        _fcmToken ?? 'Loading...',
                        style: TextStyle(fontSize: 12, fontFamily: 'monospace'),
                      ),
                    ),
                    SizedBox(height: 8),
                    ElevatedButton.icon(
                      onPressed: _fcmToken != null ? () => _copyToken() : null,
                      icon: Icon(Icons.copy),
                      label: Text('Copy Token'),
                    ),
                  ],
                ),
              ),
            ),
            
            SizedBox(height: 16),
            
            // Test Notifications
            Text(
              'Test Notifications',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            
            _NotificationButton(
              title: 'Send Local Notification',
              description: 'Test notification without server',
              icon: Icons.notifications_active,
              onPressed: () => _sendTestNotification(),
            ),
            
            SizedBox(height: 12),
            
            _NotificationButton(
              title: 'Schedule Notification',
              description: 'Schedule for 10 seconds from now',
              icon: Icons.schedule,
              onPressed: () => _scheduleTestNotification(),
            ),
            
            SizedBox(height: 12),
            
            _NotificationButton(
              title: 'Order Ready Notification',
              description: 'Simulate order completion',
              icon: Icons.restaurant,
              onPressed: () => _sendOrderNotification(),
            ),
            
            SizedBox(height: 12),
            
            _NotificationButton(
              title: 'Message Notification',
              description: 'Simulate new message',
              icon: Icons.message,
              onPressed: () => _sendMessageNotification(),
            ),
            
            SizedBox(height: 12),
            
            _NotificationButton(
              title: 'Promotion Notification',
              description: 'Simulate promotional offer',
              icon: Icons.local_offer,
              onPressed: () => _sendPromotionNotification(),
            ),
            
            SizedBox(height: 24),
            
            // Instructions
            Card(
              color: Colors.blue[50],
              child: Padding(
                padding: EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(Icons.info, color: Colors.blue),
                        SizedBox(width: 8),
                        Text(
                          'How to Test Push Notifications',
                          style: TextStyle(
                            fontWeight: FontWeight.bold,
                            color: Colors.blue[800],
                          ),
                        ),
                      ],
                    ),
                    SizedBox(height: 12),
                    Text(
                      '1. Copy the FCM token above\n'
                      '2. Use Firebase Console or server to send notifications\n'
                      '3. Test local notifications with buttons above\n'
                      '4. Put app in background to test real push notifications',
                      style: TextStyle(color: Colors.blue[700]),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  void _copyToken() {
    Clipboard.setData(ClipboardData(text: _fcmToken!));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('FCM Token copied to clipboard')),
    );
  }
  
  Future<void> _sendTestNotification() async {
    await _notificationService.sendLocalNotification(
      title: 'Test Notification',
      body: 'This is a test notification sent locally!',
      payload: 'test_notification',
    );
  }
  
  Future<void> _scheduleTestNotification() async {
    final scheduledDate = DateTime.now().add(Duration(seconds: 10));
    await _notificationService.scheduleNotification(
      title: 'Scheduled Notification',
      body: 'This notification was scheduled 10 seconds ago!',
      scheduledDate: scheduledDate,
      payload: 'scheduled_notification',
    );
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Notification scheduled for 10 seconds from now')),
    );
  }
  
  Future<void> _sendOrderNotification() async {
    await _notificationService.sendLocalNotification(
      title: '🍕 Order Ready!',
      body: 'Your delicious pizza is ready for pickup. Order #12345',
      payload: 'order_ready_12345',
    );
  }
  
  Future<void> _sendMessageNotification() async {
    await _notificationService.sendLocalNotification(
      title: '💬 New Message',
      body: 'John: Hey! Are we still meeting for lunch today?',
      payload: 'message_john_123',
    );
  }
  
  Future<void> _sendPromotionNotification() async {
    await _notificationService.sendLocalNotification(
      title: '🎉 Special Offer!',
      body: '50% off your next order! Use code SAVE50. Valid until tomorrow.',
      payload: 'promotion_save50',
    );
  }
}

class _NotificationButton extends StatelessWidget {
  final String title;
  final String description;
  final IconData icon;
  final VoidCallback onPressed;
  
  const _NotificationButton({
    required this.title,
    required this.description,
    required this.icon,
    required this.onPressed,
  });
  
  @override
  Widget build(BuildContext context) {
    return Card(
      child: InkWell(
        onTap: onPressed,
        child: Padding(
          padding: EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                padding: EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.blue[100],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(icon, color: Colors.blue),
              ),
              SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    Text(
                      description,
                      style: TextStyle(
                        color: Colors.grey[600],
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
              Icon(Icons.send, color: Colors.blue),
            ],
          ),
        ),
      ),
    );
  }
}
```

### 1.2 Server-Side Push Notification Sending

```dart
// 🔧 SERVER HELPER (for sending notifications from your backend)
class PushNotificationSender {
  final String serverKey = 'YOUR_FIREBASE_SERVER_KEY'; // Get from Firebase Console
  
  // 📤 SEND NOTIFICATION TO SPECIFIC USER
  Future<bool> sendNotificationToUser({
    required String fcmToken,
    required String title,
    required String body,
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('https://fcm.googleapis.com/fcm/send'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'key=$serverKey',
        },
        body: jsonEncode({
          'to': fcmToken,
          'notification': {
            'title': title,
            'body': body,
            'sound': 'default',
          },
          'data': data ?? {},
          'priority': 'high',
        }),
      );
      
      return response.statusCode == 200;
    } catch (e) {
      print('Error sending notification: $e');
      return false;
    }
  }
  
  // 📤 SEND NOTIFICATION TO MULTIPLE USERS
  Future<bool> sendNotificationToMultipleUsers({
    required List<String> fcmTokens,
    required String title,
    required String body,
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('https://fcm.googleapis.com/fcm/send'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'key=$serverKey',
        },
        body: jsonEncode({
          'registration_ids': fcmTokens,
          'notification': {
            'title': title,
            'body': body,
            'sound': 'default',
          },
          'data': data ?? {},
          'priority': 'high',
        }),
      );
      
      return response.statusCode == 200;
    } catch (e) {
      print('Error sending notification: $e');
      return false;
    }
  }
  
  // 📤 SEND NOTIFICATION TO TOPIC (all subscribers)
  Future<bool> sendNotificationToTopic({
    required String topic,
    required String title,
    required String body,
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await http.post(
        Uri.parse('https://fcm.googleapis.com/fcm/send'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'key=$serverKey',
        },
        body: jsonEncode({
          'to': '/topics/$topic',
          'notification': {
            'title': title,
            'body': body,
            'sound': 'default',
          },
          'data': data ?? {},
          'priority': 'high',
        }),
      );
      
      return response.statusCode == 200;
    } catch (e) {
      print('Error sending notification: $e');
      return false;
    }
  }
}

// 📱 TOPIC SUBSCRIPTION MANAGEMENT
class TopicManager {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  
  // ➕ SUBSCRIBE TO TOPIC
  Future<void> subscribeToTopic(String topic) async {
    try {
      await _messaging.subscribeToTopic(topic);
      print('✅ Subscribed to topic: $topic');
    } catch (e) {
      print('❌ Error subscribing to topic: $e');
    }
  }
  
  // ➖ UNSUBSCRIBE FROM TOPIC
  Future<void> unsubscribeFromTopic(String topic) async {
    try {
      await _messaging.unsubscribeFromTopic(topic);
      print('✅ Unsubscribed from topic: $topic');
    } catch (e) {
      print('❌ Error unsubscribing from topic: $e');
    }
  }
  
  // 📋 COMMON TOPICS
  static const String NEWS_TOPIC = 'news';
  static const String PROMOTIONS_TOPIC = 'promotions';
  static const String UPDATES_TOPIC = 'app_updates';
  static const String ORDERS_TOPIC = 'order_updates';
}
```

---

## 2. Advanced Error Handling & Logging

Error handling and logging are like having a **smart security system** for your app that catches problems and helps you fix them.

### How Error Handling Works

```
🛡️ ERROR HANDLING FLOW
┌─────────────────────────────────────────────────────────────┐
│  1. 💥 ERROR OCCURS                                        │
│     • Network failure                                      │
│     • Invalid data                                         │
│     • User does something unexpected                       │
└─────────────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────────────┐
│  2. 🕷️ ERROR CATCHER                                       │
│     • try/catch blocks                                     │
│     • Global error handlers                               │
│     • FlutterError.onError                                │
└─────────────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────────────┐
│  3. 📝 LOGGER                                              │
│     • Records what happened                               │
│     • Adds context (time, user, device)                   │
│     • Sends to analytics service                          │
└─────────────────────────────────────────────────────────────┘
           ↓
┌─────────────────────────────────────────────────────────────┐
│  4. 🎭 USER EXPERIENCE                                     │
│     • Shows friendly error message                        │
│     • Provides retry options                              │
│     • Continues working when possible                     │
└─────────────────────────────────────────────────────────────┘
```

### 2.1 Comprehensive Error Handling System

```dart
// 📱 ERROR HANDLING DEPENDENCIES
/*
dependencies:
  firebase_crashlytics: ^3.4.8
  logger: ^2.0.2+1
  dio: ^5.3.2
  connectivity_plus: ^5.0.2
*/

import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:logger/logger.dart';
import 'package:dio/dio.dart';
import 'package:connectivity_plus/connectivity_plus.dart';

// 🔧 CUSTOM ERROR TYPES
abstract class AppError implements Exception {
  final String message;
  final String code;
  final dynamic originalError;
  
  AppError({
    required this.message,
    required this.code,
    this.originalError,
  });
  
  @override
  String toString() => 'AppError($code): $message';
}

class NetworkError extends AppError {
  NetworkError({
    required String message,
    dynamic originalError,
  }) : super(
    message: message,
    code: 'NETWORK_ERROR',
    originalError: originalError,
  );
}

class ValidationError extends AppError {
  final Map<String, String> fieldErrors;
  
  ValidationError({
    required String message,
    required this.fieldErrors,
  }) : super(
    message: message,
    code: 'VALIDATION_ERROR',
  );
}

class AuthenticationError extends AppError {
  AuthenticationError({
    required String message,
    dynamic originalError,
  }) : super(
    message: message,
    code: 'AUTH_ERROR',
    originalError: originalError,
  );
}

class ServerError extends AppError {
  final int? statusCode;
  
  ServerError({
    required String message,
    this.statusCode,
    dynamic originalError,
  }) : super(
    message: message,
    code: 'SERVER_ERROR',
    originalError: originalError,
  );
}

class DataParsingError extends AppError {
  DataParsingError({
    required String message,
    dynamic originalError,
  }) : super(
    message: message,
    code: 'DATA_PARSING_ERROR',
    originalError: originalError,
  );
}

// 📝 ADVANCED LOGGER SERVICE
class LoggerService {
  static final LoggerService _instance = LoggerService._internal();
  factory LoggerService() => _instance;
  LoggerService._internal();
  
  late Logger _logger;
  late FirebaseCrashlytics _crashlytics;
  
  void initialize() {
    _logger = Logger(
      printer: PrettyPrinter(
        methodCount: 2,
        errorMethodCount: 8,
        lineLength: 120,
        colors: true,
        printEmojis: true,
        printTime: true,
      ),
    );
    
    _crashlytics = FirebaseCrashlytics.instance;
    
    // Set up global error handling
    FlutterError.onError = (FlutterErrorDetails details) {
      logError(
        'Flutter Error',
        details.exception,
        details.stack,
        details: details.toString(),
      );
    };
    
    // Handle errors outside of Flutter
    PlatformDispatcher.instance.onError = (error, stack) {
      logError('Platform Error', error, stack);
      return true;
    };
  }
  
  // 📝 LOG LEVELS
  void logDebug(String message, {Map<String, dynamic>? extra}) {
    _logger.d(message);
    _logToCrashlytics('DEBUG', message, extra);
  }
  
  void logInfo(String message, {Map<String, dynamic>? extra}) {
    _logger.i(message);
    _logToCrashlytics('INFO', message, extra);
  }
  
  void logWarning(String message, {Map<String, dynamic>? extra}) {
    _logger.w(message);
    _logToCrashlytics('WARNING', message, extra);
  }
  
  void logError(
    String message,
    dynamic error, [
    StackTrace? stackTrace,
    String? details,
  ]) {
    _logger.e(message, error, stackTrace);
    
    // Send to Crashlytics
    _crashlytics.recordError(
      error,
      stackTrace,
      reason: message,
      information: [if (details != null) details],
    );
  }
  
  // 🔍 LOG USER ACTIONS
  void logUserAction(String action, {Map<String, dynamic>? parameters}) {
    final logMessage = 'User Action: $action';
    _logger.i(logMessage);
    
    // Log to Crashlytics as breadcrumb
    _crashlytics.log(logMessage);
    
    // Set custom keys for debugging
    if (parameters != null) {
      parameters.forEach((key, value) {
        _crashlytics.setCustomKey(key, value.toString());
      });
    }
  }
  
  // 📊 LOG PERFORMANCE
  void logPerformance(String operation, Duration duration, {bool isSuccess = true}) {
    final message = 'Performance: $operation took ${duration.inMilliseconds}ms - ${isSuccess ? 'SUCCESS' : 'FAILED'}';
    _logger.i(message);
    _crashlytics.log(message);
  }
  
  // 🌐 LOG NETWORK REQUESTS
  void logNetworkRequest(String method, String url, int statusCode, Duration duration) {
    final message = 'Network: $method $url - $statusCode (${duration.inMilliseconds}ms)';
    _logger.i(message);
    _crashlytics.log(message);
  }
  
  // 👤 SET USER CONTEXT
  void setUserContext(String userId, {String? email, String? name}) {
    _crashlytics.setUserIdentifier(userId);
    if (email != null) _crashlytics.setCustomKey('user_email', email);
    if (name != null) _crashlytics.setCustomKey('user_name', name);
  }
  
  void _logToCrashlytics(String level, String message, Map<String, dynamic>? extra) {
    _crashlytics.log('[$level] $message');
    
    if (extra != null) {
      extra.forEach((key, value) {
        _crashlytics.setCustomKey(key, value.toString());
      });
    }
  }
}

// 🌐 NETWORK ERROR HANDLER
class NetworkErrorHandler {
  static final LoggerService _logger = LoggerService();
  
  static AppError handleDioError(DioException error) {
    _logger.logError('Network Error', error, error.stackTrace);
    
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
        return NetworkError(
          message: 'Connection timeout. Please check your internet connection.',
          originalError: error,
        );
        
      case DioExceptionType.sendTimeout:
        return NetworkError(
          message: 'Request timeout. Please try again.',
          originalError: error,
        );
        
      case DioExceptionType.receiveTimeout:
        return NetworkError(
          message: 'Server response timeout. Please try again.',
          originalError: error,
        );
        
      case DioExceptionType.badResponse:
        final statusCode = error.response?.statusCode ?? 0;
        
        if (statusCode >= 400 && statusCode < 500) {
          if (statusCode == 401) {
            return AuthenticationError(
              message: 'Please log in again.',
              originalError: error,
            );
          } else if (statusCode == 403) {
            return AuthenticationError(
              message: 'You don\'t have permission to access this resource.',
              originalError: error,
            );
          } else if (statusCode == 404) {
            return ServerError(
              message: 'The requested resource was not found.',
              statusCode: statusCode,
              originalError: error,
            );
          } else {
            return ValidationError(
              message: 'Invalid request. Please check your input.',
              fieldErrors: _extractFieldErrors(error.response?.data),
            );
          }
        } else if (statusCode >= 500) {
          return ServerError(
            message: 'Server error. Please try again later.',
            statusCode: statusCode,
            originalError: error,
          );
        } else {
          return ServerError(
            message: 'Unknown server error.',
            statusCode: statusCode,
            originalError: error,
          );
        }
        
      case DioExceptionType.cancel:
        return NetworkError(
          message: 'Request was cancelled.',
          originalError: error,
        );
        
      case DioExceptionType.connectionError:
        return NetworkError(
          message: 'No internet connection. Please check your network.',
          originalError: error,
        );
        
      default:
        return NetworkError(
          message: 'Network error occurred. Please try again.',
          originalError: error,
        );
    }
  }
  
  static Map<String, String> _extractFieldErrors(dynamic responseData) {
    if (responseData is Map<String, dynamic> && responseData.containsKey('errors')) {
      final errors = responseData['errors'];
      if (errors is Map<String, dynamic>) {
        return errors.map((key, value) => MapEntry(key, value.toString()));
      }
    }
    return {};
  }
}

// 🛡️ ERROR BOUNDARY WIDGET
class ErrorBoundary extends StatefulWidget {
  final Widget child;
  final Widget Function(Object error, StackTrace stackTrace)? errorBuilder;
  
  const ErrorBoundary({
    Key? key,
    required this.child,
    this.errorBuilder,
  }) : super(key: key);
  
  @override
  _ErrorBoundaryState createState() => _ErrorBoundaryState();
}

class _ErrorBoundaryState extends State<ErrorBoundary> {
  Object? _error;
  StackTrace? _stackTrace;
  
  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return widget.errorBuilder?.call(_error!, _stackTrace!) ??
          _DefaultErrorWidget(error: _error!, stackTrace: _stackTrace!);
    }
    
    return widget.child;
  }
  
  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    ErrorWidget.builder = (FlutterErrorDetails details) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        setState(() {
          _error = details.exception;
          _stackTrace = details.stack;
        });
      });
      return SizedBox.shrink();
    };
  }
}

class _DefaultErrorWidget extends StatelessWidget {
  final Object error;
  final StackTrace stackTrace;
  
  const _DefaultErrorWidget({
    required this.error,
    required this.stackTrace,
  });
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Something went wrong')),
      body: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 64, color: Colors.red),
            SizedBox(height: 16),
            Text(
              'Oops! Something went wrong',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Text(
              'We apologize for the inconvenience. The error has been reported.',
              textAlign: TextAlign.center,
              style: TextStyle(color: Colors.grey[600]),
            ),
            SizedBox(height: 24),
            ElevatedButton(
              onPressed: () {
                // Restart the app or navigate to home
                Navigator.of(context).pushNamedAndRemoveUntil(
                  '/',
                  (route) => false,
                );
              },
              child: Text('Go to Home'),
            ),
            SizedBox(height: 12),
            TextButton(
              onPressed: () {
                // Show error details
                _showErrorDetails(context);
              },
              child: Text('Show Details'),
            ),
          ],
        ),
      ),
    );
  }
  
  void _showErrorDetails(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Error Details'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text('Error: ${error.toString()}'),
              SizedBox(height: 8),
              Text('Stack Trace:'),
              SizedBox(height: 4),
              Text(
                stackTrace.toString(),
                style: TextStyle(fontSize: 10, fontFamily: 'monospace'),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Close'),
          ),
        ],
      ),
    );
  }
}

// 🎯 RESULT WRAPPER FOR ERROR HANDLING
class Result<T> {
  final T? data;
  final AppError? error;
  final bool isSuccess;
  
  Result._({this.data, this.error, required this.isSuccess});
  
  factory Result.success(T data) {
    return Result._(data: data, isSuccess: true);
  }
  
  factory Result.failure(AppError error) {
    return Result._(error: error, isSuccess: false);
  }
  
  // Convenient getters
  bool get isFailure => !isSuccess;
  T get value => data!;
  AppError get errorValue => error!;
  
  // Transform result
  Result<U> map<U>(U Function(T data) transform) {
    if (isSuccess) {
      try {
        return Result.success(transform(data!));
      } catch (e) {
        return Result.failure(AppError(
          message: 'Transform error: $e',
          code: 'TRANSFORM_ERROR',
        ));
      }
    } else {
      return Result.failure(error!);
    }
  }
  
  // Handle both success and failure
  U when<U>({
    required U Function(T data) onSuccess,
    required U Function(AppError error) onFailure,
  }) {
    if (isSuccess) {
      return onSuccess(data!);
    } else {
      return onFailure(error!);
    }
  }
}

// 📱 ERROR HANDLING DEMO SCREEN
class ErrorHandlingDemoScreen extends StatefulWidget {
  @override
  _ErrorHandlingDemoScreenState createState() => _ErrorHandlingDemoScreenState();
}

class _ErrorHandlingDemoScreenState extends State<ErrorHandlingDemoScreen> {
  final LoggerService _logger = LoggerService();
  String _lastResult = '';
  
  @override
  void initState() {
    super.initState();
    _logger.setUserContext('demo_user_123', email: 'demo@example.com');
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Error Handling & Logging Demo')),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Logging Examples
            Text(
              'Logging Examples',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            
            _DemoButton(
              title: 'Log Debug Message',
              description: 'Send debug information',
              icon: Icons.bug_report,
              onPressed: () => _logDebugExample(),
            ),
            
            _DemoButton(
              title: 'Log User Action',
              description: 'Track user behavior',
              icon: Icons.person_pin_circle,
              onPressed: () => _logUserActionExample(),
            ),
            
            _DemoButton(
              title: 'Log Performance',
              description: 'Track app performance',
              icon: Icons.speed,
              onPressed: () => _logPerformanceExample(),
            ),
            
            SizedBox(height: 24),
            
            // Error Examples
            Text(
              'Error Handling Examples',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            
            _DemoButton(
              title: 'Simulate Network Error',
              description: 'Test network error handling',
              icon: Icons.cloud_off,
              onPressed: () => _simulateNetworkError(),
            ),
            
            _DemoButton(
              title: 'Simulate Validation Error',
              description: 'Test form validation errors',
              icon: Icons.error_outline,
              onPressed: () => _simulateValidationError(),
            ),
            
            _DemoButton(
              title: 'Simulate Crash',
              description: 'Test crash reporting',
              icon: Icons.warning,
              onPressed: () => _simulateCrash(),
            ),
            
            _DemoButton(
              title: 'Test Error Boundary',
              description: 'Test widget error handling',
              icon: Icons.shield,
              onPressed: () => _testErrorBoundary(),
            ),
            
            SizedBox(height: 24),
            
            // Result Display
            if (_lastResult.isNotEmpty) ...[
              Text(
                'Last Result',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              SizedBox(height: 8),
              Container(
                padding: EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey[100],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  _lastResult,
                  style: TextStyle(fontSize: 12, fontFamily: 'monospace'),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
  
  void _logDebugExample() {
    _logger.logDebug(
      'User opened error handling demo screen',
      extra: {
        'screen': 'ErrorHandlingDemo',
        'timestamp': DateTime.now().toIso8601String(),
        'user_action': 'debug_log_test',
      },
    );
    
    setState(() {
      _lastResult = 'Debug message logged successfully';
    });
  }
  
  void _logUserActionExample() {
    _logger.logUserAction(
      'button_clicked',
      parameters: {
        'button_name': 'log_user_action',
        'screen': 'error_demo',
        'session_duration': '120_seconds',
      },
    );
    
    setState(() {
      _lastResult = 'User action logged with parameters';
    });
  }
  
  void _logPerformanceExample() {
    final stopwatch = Stopwatch()..start();
    
    // Simulate some work
    Future.delayed(Duration(milliseconds: 200), () {
      stopwatch.stop();
      _logger.logPerformance(
        'data_loading',
        stopwatch.elapsed,
        isSuccess: true,
      );
      
      setState(() {
        _lastResult = 'Performance logged: ${stopwatch.elapsed.inMilliseconds}ms';
      });
    });
  }
  
  void _simulateNetworkError() {
    try {
      // Simulate a network error
      final dioError = DioException(
        requestOptions: RequestOptions(path: '/api/test'),
        type: DioExceptionType.connectionTimeout,
      );
      
      final appError = NetworkErrorHandler.handleDioError(dioError);
      
      setState(() {
        _lastResult = 'Network Error: ${appError.message}';
      });
      
      _showErrorDialog(appError);
    } catch (e) {
      _logger.logError('Error in simulateNetworkError', e);
    }
  }
  
  void _simulateValidationError() {
    final validationError = ValidationError(
      message: 'Form validation failed',
      fieldErrors: {
        'email': 'Please enter a valid email address',
        'password': 'Password must be at least 8 characters',
        'phone': 'Phone number is required',
      },
    );
    
    _logger.logError('Validation Error', validationError);
    
    setState(() {
      _lastResult = 'Validation Error: ${validationError.fieldErrors}';
    });
    
    _showErrorDialog(validationError);
  }
  
  void _simulateCrash() {
    try {
      // Force a crash for testing
      throw Exception('This is a test crash for Crashlytics');
    } catch (e, stackTrace) {
      _logger.logError('Simulated Crash', e, stackTrace);
      
      setState(() {
        _lastResult = 'Crash logged to Crashlytics: ${e.toString()}';
      });
    }
  }
  
  void _testErrorBoundary() {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => ErrorBoundary(
          child: _CrashyWidget(),
        ),
      ),
    );
  }
  
  void _showErrorDialog(AppError error) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.error, color: Colors.red),
            SizedBox(width: 8),
            Text('Error'),
          ],
        ),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Type: ${error.code}'),
            SizedBox(height: 8),
            Text('Message: ${error.message}'),
            if (error is ValidationError && error.fieldErrors.isNotEmpty) ...[
              SizedBox(height: 8),
              Text('Field Errors:'),
              ...error.fieldErrors.entries.map(
                (entry) => Text('• ${entry.key}: ${entry.value}'),
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('OK'),
          ),
        ],
      ),
    );
  }
}

class _DemoButton extends StatelessWidget {
  final String title;
  final String description;
  final IconData icon;
  final VoidCallback onPressed;
  
  const _DemoButton({
    required this.title,
    required this.description,
    required this.icon,
    required this.onPressed,
  });
  
  @override
  Widget build(BuildContext context) {
    return Card(
      child: InkWell(
        onTap: onPressed,
        child: Padding(
          padding: EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                padding: EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.blue[100],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(icon, color: Colors.blue),
              ),
              SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    Text(
                      description,
                      style: TextStyle(
                        color: Colors.grey[600],
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
              Icon(Icons.play_arrow, color: Colors.blue),
            ],
          ),
        ),
      ),
    );
  }
}

class _CrashyWidget extends StatefulWidget {
  @override
  _CrashyWidgetState createState() => _CrashyWidgetState();
}

class _CrashyWidgetState extends State<_CrashyWidget> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Error Boundary Test')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('This screen will crash when you tap the button'),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: () {
                // This will cause an error
                throw Exception('Test widget error');
              },
              child: Text('Cause Error'),
            ),
          ],
        ),
      ),
    );
  }
}

// 🚀 MAIN APP SETUP
class BackendServicesApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Backend & Services Demo',
      home: BackendServicesMenu(),
    );
  }
}

class BackendServicesMenu extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Backend & Services')),
      body: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _ServiceCard(
              icon: Icons.notifications,
              title: 'Push Notifications',
              description: 'FCM setup, local notifications, and testing',
              onTap: () => Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => NotificationDemoScreen()),
              ),
            ),
            SizedBox(height: 16),
            _ServiceCard(
              icon: Icons.error_outline,
              title: 'Error Handling & Logging',
              description: 'Crashlytics, logging, and error boundaries',
              onTap: () => Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => ErrorHandlingDemoScreen()),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ServiceCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String description;
  final VoidCallback onTap;
  
  const _ServiceCard({
    required this.icon,
    required this.title,
    required this.description,
    required this.onTap,
  });
  
  @override
  Widget build(BuildContext context) {
    return Card(
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                padding: EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.blue[100],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(icon, size: 32, color: Colors.blue),
              ),
              SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    SizedBox(height: 4),
                    Text(
                      description,
                      style: TextStyle(color: Colors.grey[600]),
                    ),
                  ],
                ),
              ),
              Icon(Icons.arrow_forward_ios, color: Colors.grey),
            ],
          ),
        ),
      ),
    );
  }
}

// Import statements for the required packages
import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:http/http.dart' as http;
import 'package:timezone/timezone.dart' as tz;
import 'dart:ui';

## Summary

### 🔔 **Push Notifications Key Points:**
1. **Firebase Cloud Messaging (FCM)**: Google's free service for push notifications
2. **Local Notifications**: Show notifications within the app
3. **Scheduled Notifications**: Send notifications at specific times
4. **Topic Subscriptions**: Send notifications to groups of users
5. **Rich Notifications**: Include images, actions, and custom data

### 🛡️ **Error Handling & Logging Key Points:**
1. **Comprehensive Error Types**: Network, validation, authentication, server errors
2. **Global Error Handling**: Catch all errors automatically
3. **Firebase Crashlytics**: Track crashes and errors in production
4. **Logging Service**: Track user actions, performance, and debugging info
5. **Error Boundaries**: Gracefully handle widget errors
6. **Result Wrapper**: Type-safe error handling

### 📋 **Best Practices:**

**Push Notifications:**
- Request permissions properly
- Handle all notification states (foreground, background, terminated)
- Use meaningful titles and messages
- Include relevant data for navigation
- Test on real devices

**Error Handling:**
- Always provide user-friendly error messages
- Log errors with context for debugging
- Use try-catch blocks for risky operations
- Implement retry mechanisms for network errors
- Don't expose technical details to users

**Logging:**
- Log user actions for analytics
- Track performance metrics
- Include user context for debugging
- Use appropriate log levels
- Remove sensitive data from logs

### 🎯 **Real-World Use Cases:**

**Push Notifications:**
- Order status updates
- New message alerts
- Promotional offers
- Breaking news
- Appointment reminders

**Error Handling:**
- Network connectivity issues
- Server downtime
- Invalid user input
- Authentication failures
- Data parsing errors

This comprehensive system ensures your Flutter app can **communicate effectively with users** and **handle problems gracefully**, providing a professional and reliable user experience!