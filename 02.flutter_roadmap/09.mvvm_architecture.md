# MVVM Architecture in Flutter

MVVM (Model-View-ViewModel) is a design pattern that helps organize your Flutter app code in a clean, maintainable, and testable way. Think of it as organizing your closet - everything has its place!

## What is MVVM? (Simple Explanation)

Imagine you're building a restaurant app. Here's how MVVM works:

```
🏠 RESTAURANT APP EXAMPLE
┌─────────────────────────────────────────────────────────────┐
│                        📱 VIEW                              │
│  (The restaurant menu you see on your phone)               │
│  • Displays food items                                     │
│  • Shows prices                                            │
│  • Has "Add to Cart" buttons                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ↕️ (Talks to)
┌─────────────────────────────────────────────────────────────┐
│                      🧠 VIEW MODEL                          │
│  (The waiter who takes your order)                         │
│  • Handles button clicks                                   │
│  • Manages loading states                                  │
│  • Formats data for display                                │
│  • Decides what to show/hide                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ↕️ (Talks to)
┌─────────────────────────────────────────────────────────────┐
│                     📦 REPOSITORY                           │
│  (The kitchen manager who knows where everything is)       │
│  • Decides: get from local storage or internet?            │
│  • Caches frequently used data                             │
│  • Handles offline scenarios                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ↕️ (Gets data from)
┌─────────────────────────────────────────────────────────────┐
│                    🌐 SERVICES                              │
│  (The suppliers who provide ingredients)                   │
│  • API Service (gets data from internet)                   │
│  • Database Service (local storage)                        │
│  • Cache Service (temporary storage)                       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ↕️ (Works with)
┌─────────────────────────────────────────────────────────────┐
│                     📊 MODELS                               │
│  (The recipe cards that describe each dish)                │
│  • Food item structure                                     │
│  • User information                                        │
│  • Order details                                           │
└─────────────────────────────────────────────────────────────┘
```

### Why Use MVVM?

**Without MVVM (Everything mixed together):**
```dart
// ❌ BAD: Everything in one place
class BadFoodScreen extends StatefulWidget {
  @override
  _BadFoodScreenState createState() => _BadFoodScreenState();
}

class _BadFoodScreenState extends State<BadFoodScreen> {
  List<dynamic> foods = [];
  bool isLoading = false;
  
  @override
  void initState() {
    super.initState();
    // UI, business logic, and data fetching all mixed together!
    loadFoods();
  }
  
  void loadFoods() async {
    setState(() => isLoading = true);
    try {
      // Direct API call in UI - BAD!
      final response = await http.get(Uri.parse('https://api.example.com/foods'));
      final data = json.decode(response.body);
      setState(() {
        foods = data['foods'];
        isLoading = false;
      });
    } catch (e) {
      setState(() => isLoading = false);
      // Error handling mixed with UI - BAD!
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: $e')),
      );
    }
  }
  
  @override
  Widget build(BuildContext context) {
    // UI mixed with logic - HARD TO TEST AND MAINTAIN!
    return Scaffold(
      body: isLoading 
        ? CircularProgressIndicator()
        : ListView.builder(
            itemCount: foods.length,
            itemBuilder: (context, index) {
              final food = foods[index];
              return ListTile(
                title: Text(food['name']),
                subtitle: Text('\$${food['price']}'),
                onTap: () {
                  // More business logic in UI - BAD!
                  addToCart(food);
                },
              );
            },
          ),
    );
  }
  
  void addToCart(dynamic food) {
    // Cart logic mixed with UI - BAD!
    print('Added ${food['name']} to cart');
  }
}
```

**With MVVM (Clean separation):**
```dart
// ✅ GOOD: Clean separation of concerns
class GoodFoodScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (_) => FoodViewModel()..loadFoods(),
      child: Scaffold(
        appBar: AppBar(title: Text('Food Menu')),
        body: Consumer<FoodViewModel>(
          builder: (context, viewModel, child) {
            if (viewModel.isLoading) {
              return Center(child: CircularProgressIndicator());
            }
            
            return ListView.builder(
              itemCount: viewModel.foods.length,
              itemBuilder: (context, index) {
                final food = viewModel.foods[index];
                return FoodItemWidget(
                  food: food,
                  onTap: () => viewModel.addToCart(food),
                );
              },
            );
          },
        ),
      ),
    );
  }
}
```

## Let's Build a Complete MVVM Example

We'll build a **Todo App** using proper MVVM architecture. Here's what we'll create:

### 1. Models (Data Structures)

Think of models as **recipe cards** - they define what data looks like:

```dart
// 📊 MODEL: Defines the structure of our data
class Todo {
  final String id;
  final String title;
  final String description;
  final bool isCompleted;
  final DateTime createdAt;
  final DateTime? completedAt;
  
  Todo({
    required this.id,
    required this.title,
    required this.description,
    required this.isCompleted,
    required this.createdAt,
    this.completedAt,
  });
  
  // Convert from JSON (from API or database)
  factory Todo.fromJson(Map<String, dynamic> json) {
    return Todo(
      id: json['id'] ?? '',
      title: json['title'] ?? '',
      description: json['description'] ?? '',
      isCompleted: json['isCompleted'] ?? false,
      createdAt: DateTime.parse(json['createdAt'] ?? DateTime.now().toIso8601String()),
      completedAt: json['completedAt'] != null 
          ? DateTime.parse(json['completedAt']) 
          : null,
    );
  }
  
  // Convert to JSON (for API or database)
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'isCompleted': isCompleted,
      'createdAt': createdAt.toIso8601String(),
      'completedAt': completedAt?.toIso8601String(),
    };
  }
  
  // Create a copy with some changes
  Todo copyWith({
    String? id,
    String? title,
    String? description,
    bool? isCompleted,
    DateTime? createdAt,
    DateTime? completedAt,
  }) {
    return Todo(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      isCompleted: isCompleted ?? this.isCompleted,
      createdAt: createdAt ?? this.createdAt,
      completedAt: completedAt ?? this.completedAt,
    );
  }
  
  @override
  String toString() {
    return 'Todo{id: $id, title: $title, isCompleted: $isCompleted}';
  }
}

// Another model for API responses
class TodoResponse {
  final List<Todo> todos;
  final int total;
  final bool hasMore;
  
  TodoResponse({
    required this.todos,
    required this.total,
    required this.hasMore,
  });
  
  factory TodoResponse.fromJson(Map<String, dynamic> json) {
    return TodoResponse(
      todos: (json['todos'] as List)
          .map((todoJson) => Todo.fromJson(todoJson))
          .toList(),
      total: json['total'] ?? 0,
      hasMore: json['hasMore'] ?? false,
    );
  }
}

// Model for creating new todos
class CreateTodoRequest {
  final String title;
  final String description;
  
  CreateTodoRequest({
    required this.title,
    required this.description,
  });
  
  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'description': description,
    };
  }
}
```

### 2. Services (Data Sources)

Services are like **suppliers** - they know how to get data from different sources:

```dart
// 🌐 API SERVICE: Talks to the internet
class ApiService {
  static const String baseUrl = 'https://jsonplaceholder.typicode.com';
  final http.Client client;
  
  ApiService({http.Client? client}) : client = client ?? http.Client();
  
  // Get all todos from server
  Future<TodoResponse> getTodos() async {
    try {
      print('📡 Fetching todos from API...');
      final response = await client.get(
        Uri.parse('$baseUrl/todos'),
        headers: {'Content-Type': 'application/json'},
      );
      
      if (response.statusCode == 200) {
        final List<dynamic> jsonList = json.decode(response.body);
        final todos = jsonList.take(10).map((json) => Todo(
          id: json['id'].toString(),
          title: json['title'] ?? '',
          description: 'Description for todo ${json['id']}',
          isCompleted: json['completed'] ?? false,
          createdAt: DateTime.now().subtract(Duration(days: json['id'] % 7)),
        )).toList();
        
        return TodoResponse(
          todos: todos,
          total: todos.length,
          hasMore: false,
        );
      } else {
        throw Exception('Failed to load todos: ${response.statusCode}');
      }
    } catch (e) {
      print('❌ API Error: $e');
      throw Exception('Network error: $e');
    }
  }
  
  // Create new todo
  Future<Todo> createTodo(CreateTodoRequest request) async {
    try {
      print('📡 Creating todo: ${request.title}');
      final response = await client.post(
        Uri.parse('$baseUrl/todos'),
        headers: {'Content-Type': 'application/json'},
        body: json.encode(request.toJson()),
      );
      
      if (response.statusCode == 201) {
        final jsonResponse = json.decode(response.body);
        return Todo(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          title: request.title,
          description: request.description,
          isCompleted: false,
          createdAt: DateTime.now(),
        );
      } else {
        throw Exception('Failed to create todo: ${response.statusCode}');
      }
    } catch (e) {
      print('❌ Create Todo Error: $e');
      throw Exception('Failed to create todo: $e');
    }
  }
  
  // Update todo
  Future<Todo> updateTodo(Todo todo) async {
    try {
      print('📡 Updating todo: ${todo.id}');
      final response = await client.put(
        Uri.parse('$baseUrl/todos/${todo.id}'),
        headers: {'Content-Type': 'application/json'},
        body: json.encode(todo.toJson()),
      );
      
      if (response.statusCode == 200) {
        return todo;
      } else {
        throw Exception('Failed to update todo: ${response.statusCode}');
      }
    } catch (e) {
      print('❌ Update Todo Error: $e');
      throw Exception('Failed to update todo: $e');
    }
  }
  
  // Delete todo
  Future<bool> deleteTodo(String id) async {
    try {
      print('📡 Deleting todo: $id');
      final response = await client.delete(
        Uri.parse('$baseUrl/todos/$id'),
        headers: {'Content-Type': 'application/json'},
      );
      
      return response.statusCode == 200;
    } catch (e) {
      print('❌ Delete Todo Error: $e');
      throw Exception('Failed to delete todo: $e');
    }
  }
}

// 💾 LOCAL DATABASE SERVICE: Stores data locally
class DatabaseService {
  static const String _todosKey = 'todos';
  final SharedPreferences _prefs;
  
  DatabaseService(this._prefs);
  
  // Save todos to local storage
  Future<void> saveTodos(List<Todo> todos) async {
    try {
      print('💾 Saving ${todos.length} todos to local storage');
      final todosJson = todos.map((todo) => todo.toJson()).toList();
      await _prefs.setString(_todosKey, json.encode(todosJson));
    } catch (e) {
      print('❌ Database Save Error: $e');
      throw Exception('Failed to save todos locally: $e');
    }
  }
  
  // Load todos from local storage
  Future<List<Todo>> loadTodos() async {
    try {
      print('💾 Loading todos from local storage');
      final todosString = _prefs.getString(_todosKey);
      if (todosString == null) return [];
      
      final List<dynamic> todosJson = json.decode(todosString);
      return todosJson.map((json) => Todo.fromJson(json)).toList();
    } catch (e) {
      print('❌ Database Load Error: $e');
      return [];
    }
  }
  
  // Clear all todos
  Future<void> clearTodos() async {
    await _prefs.remove(_todosKey);
  }
}

// 🧠 CACHE SERVICE: Temporary fast storage
class CacheService {
  static final Map<String, dynamic> _cache = {};
  static const Duration defaultExpiry = Duration(minutes: 15);
  
  // Store data with expiry
  static void set(String key, dynamic data, {Duration? expiry}) {
    final expiryTime = DateTime.now().add(expiry ?? defaultExpiry);
    _cache[key] = {
      'data': data,
      'expiry': expiryTime,
    };
    print('🧠 Cached: $key (expires at $expiryTime)');
  }
  
  // Get data if not expired
  static T? get<T>(String key) {
    final cached = _cache[key];
    if (cached == null) {
      print('🧠 Cache miss: $key');
      return null;
    }
    
    final expiry = cached['expiry'] as DateTime;
    if (DateTime.now().isAfter(expiry)) {
      _cache.remove(key);
      print('🧠 Cache expired: $key');
      return null;
    }
    
    print('🧠 Cache hit: $key');
    return cached['data'] as T;
  }
  
  // Clear specific key
  static void remove(String key) {
    _cache.remove(key);
    print('🧠 Cache cleared: $key');
  }
  
  // Clear all cache
  static void clear() {
    _cache.clear();
    print('🧠 All cache cleared');
  }
}
```

### 3. Repository (Data Manager)

Repository is like a **kitchen manager** - decides where to get data from:

```dart
// 📦 REPOSITORY: Manages data from multiple sources
class TodoRepository {
  final ApiService _apiService;
  final DatabaseService _databaseService;
  
  static const String _todosKey = 'todos_cache';
  
  TodoRepository({
    required ApiService apiService,
    required DatabaseService databaseService,
  }) : _apiService = apiService,
       _databaseService = databaseService;
  
  // Get todos (smart strategy: cache -> local -> api)
  Future<List<Todo>> getTodos({bool forceRefresh = false}) async {
    try {
      // 1. Try cache first (fastest)
      if (!forceRefresh) {
        final cachedTodos = CacheService.get<List<Todo>>(_todosKey);
        if (cachedTodos != null && cachedTodos.isNotEmpty) {
          print('📦 Repository: Returning cached todos');
          return cachedTodos;
        }
      }
      
      // 2. Try API (most up-to-date)
      try {
        print('📦 Repository: Fetching from API');
        final response = await _apiService.getTodos();
        
        // Save to local database for offline access
        await _databaseService.saveTodos(response.todos);
        
        // Cache for quick access
        CacheService.set(_todosKey, response.todos);
        
        return response.todos;
        
      } catch (apiError) {
        print('📦 Repository: API failed, trying local database');
        
        // 3. Fallback to local database (offline support)
        final localTodos = await _databaseService.loadTodos();
        if (localTodos.isNotEmpty) {
          CacheService.set(_todosKey, localTodos);
          return localTodos;
        }
        
        // 4. No data available anywhere
        throw Exception('No todos available offline and API failed: $apiError');
      }
      
    } catch (e) {
      print('❌ Repository Error: $e');
      rethrow;
    }
  }
  
  // Create new todo
  Future<Todo> createTodo(CreateTodoRequest request) async {
    try {
      print('📦 Repository: Creating todo');
      
      // Try API first
      final newTodo = await _apiService.createTodo(request);
      
      // Update local storage
      final existingTodos = await _databaseService.loadTodos();
      existingTodos.add(newTodo);
      await _databaseService.saveTodos(existingTodos);
      
      // Update cache
      CacheService.set(_todosKey, existingTodos);
      
      return newTodo;
      
    } catch (e) {
      print('❌ Repository Create Error: $e');
      
      // Offline fallback: create locally
      final offlineTodo = Todo(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        title: request.title,
        description: request.description,
        isCompleted: false,
        createdAt: DateTime.now(),
      );
      
      final existingTodos = await _databaseService.loadTodos();
      existingTodos.add(offlineTodo);
      await _databaseService.saveTodos(existingTodos);
      CacheService.set(_todosKey, existingTodos);
      
      return offlineTodo;
    }
  }
  
  // Update todo
  Future<Todo> updateTodo(Todo todo) async {
    try {
      print('📦 Repository: Updating todo ${todo.id}');
      
      // Update via API
      final updatedTodo = await _apiService.updateTodo(todo);
      
      // Update local storage
      final existingTodos = await _databaseService.loadTodos();
      final index = existingTodos.indexWhere((t) => t.id == todo.id);
      if (index != -1) {
        existingTodos[index] = updatedTodo;
        await _databaseService.saveTodos(existingTodos);
        CacheService.set(_todosKey, existingTodos);
      }
      
      return updatedTodo;
      
    } catch (e) {
      print('❌ Repository Update Error: $e');
      
      // Offline fallback: update locally
      final existingTodos = await _databaseService.loadTodos();
      final index = existingTodos.indexWhere((t) => t.id == todo.id);
      if (index != -1) {
        existingTodos[index] = todo;
        await _databaseService.saveTodos(existingTodos);
        CacheService.set(_todosKey, existingTodos);
      }
      
      return todo;
    }
  }
  
  // Delete todo
  Future<bool> deleteTodo(String id) async {
    try {
      print('📦 Repository: Deleting todo $id');
      
      // Delete via API
      final success = await _apiService.deleteTodo(id);
      
      if (success) {
        // Remove from local storage
        final existingTodos = await _databaseService.loadTodos();
        existingTodos.removeWhere((todo) => todo.id == id);
        await _databaseService.saveTodos(existingTodos);
        CacheService.set(_todosKey, existingTodos);
      }
      
      return success;
      
    } catch (e) {
      print('❌ Repository Delete Error: $e');
      
      // Offline fallback: delete locally
      final existingTodos = await _databaseService.loadTodos();
      existingTodos.removeWhere((todo) => todo.id == id);
      await _databaseService.saveTodos(existingTodos);
      CacheService.set(_todosKey, existingTodos);
      
      return true;
    }
  }
  
  // Search todos
  Future<List<Todo>> searchTodos(String query) async {
    final todos = await getTodos();
    return todos.where((todo) {
      return todo.title.toLowerCase().contains(query.toLowerCase()) ||
             todo.description.toLowerCase().contains(query.toLowerCase());
    }).toList();
  }
  
  // Get completed todos
  Future<List<Todo>> getCompletedTodos() async {
    final todos = await getTodos();
    return todos.where((todo) => todo.isCompleted).toList();
  }
  
  // Get pending todos
  Future<List<Todo>> getPendingTodos() async {
    final todos = await getTodos();
    return todos.where((todo) => !todo.isCompleted).toList();
  }
}
```

### 4. ViewModel (Business Logic)

ViewModel is like a **smart waiter** - handles all the logic and talks to the UI:

```dart
// 🧠 VIEW MODEL: Manages UI state and business logic
class TodoViewModel extends ChangeNotifier {
  final TodoRepository _repository;
  
  // State variables
  List<Todo> _todos = [];
  bool _isLoading = false;
  String? _error;
  String _searchQuery = '';
  TodoFilter _filter = TodoFilter.all;
  
  // Getters (what the UI can see)
  List<Todo> get todos => _getFilteredTodos();
  bool get isLoading => _isLoading;
  String? get error => _error;
  String get searchQuery => _searchQuery;
  TodoFilter get filter => _filter;
  bool get hasError => _error != null;
  int get totalTodos => _todos.length;
  int get completedTodos => _todos.where((todo) => todo.isCompleted).length;
  int get pendingTodos => _todos.where((todo) => !todo.isCompleted).length;
  
  TodoViewModel(this._repository);
  
  // Initialize - load todos when ViewModel is created
  Future<void> init() async {
    await loadTodos();
  }
  
  // Load todos from repository
  Future<void> loadTodos({bool forceRefresh = false}) async {
    try {
      _setLoading(true);
      _clearError();
      
      print('🧠 ViewModel: Loading todos');
      final todos = await _repository.getTodos(forceRefresh: forceRefresh);
      
      _todos = todos;
      print('🧠 ViewModel: Loaded ${todos.length} todos');
      
    } catch (e) {
      _setError('Failed to load todos: $e');
      print('❌ ViewModel Load Error: $e');
    } finally {
      _setLoading(false);
    }
  }
  
  // Create new todo
  Future<void> createTodo(String title, String description) async {
    if (title.trim().isEmpty) {
      _setError('Title cannot be empty');
      return;
    }
    
    try {
      _clearError();
      
      print('🧠 ViewModel: Creating todo: $title');
      final request = CreateTodoRequest(
        title: title.trim(),
        description: description.trim(),
      );
      
      final newTodo = await _repository.createTodo(request);
      _todos.insert(0, newTodo); // Add to beginning
      
      notifyListeners();
      print('🧠 ViewModel: Todo created successfully');
      
    } catch (e) {
      _setError('Failed to create todo: $e');
      print('❌ ViewModel Create Error: $e');
    }
  }
  
  // Toggle todo completion
  Future<void> toggleTodo(Todo todo) async {
    try {
      _clearError();
      
      print('🧠 ViewModel: Toggling todo: ${todo.id}');
      final updatedTodo = todo.copyWith(
        isCompleted: !todo.isCompleted,
        completedAt: !todo.isCompleted ? DateTime.now() : null,
      );
      
      // Optimistically update UI
      final index = _todos.indexWhere((t) => t.id == todo.id);
      if (index != -1) {
        _todos[index] = updatedTodo;
        notifyListeners();
      }
      
      // Update in repository
      await _repository.updateTodo(updatedTodo);
      print('🧠 ViewModel: Todo toggled successfully');
      
    } catch (e) {
      // Revert optimistic update on error
      final index = _todos.indexWhere((t) => t.id == todo.id);
      if (index != -1) {
        _todos[index] = todo;
        notifyListeners();
      }
      
      _setError('Failed to update todo: $e');
      print('❌ ViewModel Toggle Error: $e');
    }
  }
  
  // Delete todo
  Future<void> deleteTodo(Todo todo) async {
    try {
      _clearError();
      
      print('🧠 ViewModel: Deleting todo: ${todo.id}');
      
      // Optimistically remove from UI
      _todos.removeWhere((t) => t.id == todo.id);
      notifyListeners();
      
      // Delete from repository
      final success = await _repository.deleteTodo(todo.id);
      
      if (!success) {
        // Revert if deletion failed
        _todos.add(todo);
        notifyListeners();
        _setError('Failed to delete todo');
      } else {
        print('🧠 ViewModel: Todo deleted successfully');
      }
      
    } catch (e) {
      // Revert optimistic deletion on error
      _todos.add(todo);
      notifyListeners();
      
      _setError('Failed to delete todo: $e');
      print('❌ ViewModel Delete Error: $e');
    }
  }
  
  // Search todos
  void searchTodos(String query) {
    _searchQuery = query;
    notifyListeners();
    print('🧠 ViewModel: Searching todos with query: "$query"');
  }
  
  // Filter todos
  void setFilter(TodoFilter filter) {
    _filter = filter;
    notifyListeners();
    print('🧠 ViewModel: Filter changed to: $filter');
  }
  
  // Refresh todos
  Future<void> refresh() async {
    await loadTodos(forceRefresh: true);
  }
  
  // Clear all completed todos
  Future<void> clearCompleted() async {
    try {
      _clearError();
      
      final completedTodos = _todos.where((todo) => todo.isCompleted).toList();
      print('🧠 ViewModel: Clearing ${completedTodos.length} completed todos');
      
      for (final todo in completedTodos) {
        await _repository.deleteTodo(todo.id);
      }
      
      _todos.removeWhere((todo) => todo.isCompleted);
      notifyListeners();
      
    } catch (e) {
      _setError('Failed to clear completed todos: $e');
      print('❌ ViewModel Clear Completed Error: $e');
    }
  }
  
  // Private helper methods
  List<Todo> _getFilteredTodos() {
    List<Todo> filtered = List.from(_todos);
    
    // Apply search filter
    if (_searchQuery.isNotEmpty) {
      filtered = filtered.where((todo) {
        return todo.title.toLowerCase().contains(_searchQuery.toLowerCase()) ||
               todo.description.toLowerCase().contains(_searchQuery.toLowerCase());
      }).toList();
    }
    
    // Apply status filter
    switch (_filter) {
      case TodoFilter.pending:
        filtered = filtered.where((todo) => !todo.isCompleted).toList();
        break;
      case TodoFilter.completed:
        filtered = filtered.where((todo) => todo.isCompleted).toList();
        break;
      case TodoFilter.all:
        // No additional filtering
        break;
    }
    
    return filtered;
  }
  
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }
  
  void _setError(String error) {
    _error = error;
    notifyListeners();
  }
  
  void _clearError() {
    _error = null;
    notifyListeners();
  }
  
  @override
  void dispose() {
    print('🧠 ViewModel: Disposing');
    super.dispose();
  }
}

// Filter enum
enum TodoFilter { all, pending, completed }

// Extension to get display names
extension TodoFilterExtension on TodoFilter {
  String get displayName {
    switch (this) {
      case TodoFilter.all:
        return 'All';
      case TodoFilter.pending:
        return 'Pending';
      case TodoFilter.completed:
        return 'Completed';
    }
  }
}
```

### 5. Dependency Injection (Service Locator)

Dependency Injection is like a **phone book** - helps different parts find each other:

```dart
// 🔌 DEPENDENCY INJECTION: Service locator pattern
class DependencyInjection {
  static final GetIt _getIt = GetIt.instance;
  
  // Initialize all dependencies
  static Future<void> init() async {
    print('🔌 Initializing dependencies...');
    
    // 1. Initialize SharedPreferences
    final prefs = await SharedPreferences.getInstance();
    _getIt.registerSingleton<SharedPreferences>(prefs);
    
    // 2. Register Services (Singletons - only one instance)
    _getIt.registerSingleton<ApiService>(ApiService());
    _getIt.registerSingleton<DatabaseService>(DatabaseService(prefs));
    
    // 3. Register Repository (Singleton)
    _getIt.registerSingleton<TodoRepository>(
      TodoRepository(
        apiService: _getIt<ApiService>(),
        databaseService: _getIt<DatabaseService>(),
      ),
    );
    
    // 4. Register ViewModel Factory (New instance each time)
    _getIt.registerFactory<TodoViewModel>(
      () => TodoViewModel(_getIt<TodoRepository>()),
    );
    
    print('✅ Dependencies initialized successfully');
  }
  
  // Easy access methods
  static T get<T extends Object>() => _getIt<T>();
  
  // Reset all dependencies (useful for testing)
  static Future<void> reset() async {
    await _getIt.reset();
  }
}

// Usage in main.dart:
/*
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize dependencies
  await DependencyInjection.init();
  
  runApp(MyApp());
}
*/
```

### 6. Views (UI Screens)

Views are what the **user sees and interacts with**:

```dart
// 📱 MAIN VIEW: Todo List Screen
class TodoListScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      // Create ViewModel instance from dependency injection
      create: (_) => DependencyInjection.get<TodoViewModel>()..init(),
      child: Scaffold(
        appBar: AppBar(
          title: Text('Todo App'),
          actions: [
            // Refresh button
            Consumer<TodoViewModel>(
              builder: (context, viewModel, child) {
                return IconButton(
                  icon: Icon(Icons.refresh),
                  onPressed: viewModel.isLoading ? null : viewModel.refresh,
                );
              },
            ),
          ],
        ),
        body: Column(
          children: [
            // Search and filter section
            _SearchAndFilterSection(),
            
            // Stats section
            _StatsSection(),
            
            // Todo list
            Expanded(child: _TodoListSection()),
          ],
        ),
        floatingActionButton: _AddTodoButton(),
      ),
    );
  }
}

// Search and Filter Widget
class _SearchAndFilterSection extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<TodoViewModel>(
      builder: (context, viewModel, child) {
        return Card(
          margin: EdgeInsets.all(16),
          child: Padding(
            padding: EdgeInsets.all(16),
            child: Column(
              children: [
                // Search field
                TextField(
                  decoration: InputDecoration(
                    hintText: 'Search todos...',
                    prefixIcon: Icon(Icons.search),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onChanged: viewModel.searchTodos,
                ),
                
                SizedBox(height: 16),
                
                // Filter chips
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: TodoFilter.values.map((filter) {
                    final isSelected = viewModel.filter == filter;
                    return FilterChip(
                      label: Text(filter.displayName),
                      selected: isSelected,
                      onSelected: (_) => viewModel.setFilter(filter),
                      backgroundColor: isSelected ? Colors.blue : null,
                      labelStyle: TextStyle(
                        color: isSelected ? Colors.white : null,
                      ),
                    );
                  }).toList(),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

// Stats Widget
class _StatsSection extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<TodoViewModel>(
      builder: (context, viewModel, child) {
        return Container(
          margin: EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            children: [
              Expanded(
                child: _StatCard(
                  title: 'Total',
                  count: viewModel.totalTodos,
                  color: Colors.blue,
                  icon: Icons.list,
                ),
              ),
              SizedBox(width: 8),
              Expanded(
                child: _StatCard(
                  title: 'Pending',
                  count: viewModel.pendingTodos,
                  color: Colors.orange,
                  icon: Icons.pending,
                ),
              ),
              SizedBox(width: 8),
              Expanded(
                child: _StatCard(
                  title: 'Completed',
                  count: viewModel.completedTodos,
                  color: Colors.green,
                  icon: Icons.check_circle,
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

class _StatCard extends StatelessWidget {
  final String title;
  final int count;
  final Color color;
  final IconData icon;
  
  const _StatCard({
    required this.title,
    required this.count,
    required this.color,
    required this.icon,
  });
  
  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: EdgeInsets.all(12),
        child: Column(
          children: [
            Icon(icon, color: color, size: 24),
            SizedBox(height: 4),
            Text(
              count.toString(),
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: color,
              ),
            ),
            Text(
              title,
              style: TextStyle(
                fontSize: 12,
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Todo List Widget
class _TodoListSection extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<TodoViewModel>(
      builder: (context, viewModel, child) {
        // Error state
        if (viewModel.hasError) {
          return _ErrorWidget(
            error: viewModel.error!,
            onRetry: viewModel.refresh,
          );
        }
        
        // Loading state
        if (viewModel.isLoading && viewModel.todos.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                CircularProgressIndicator(),
                SizedBox(height: 16),
                Text('Loading todos...'),
              ],
            ),
          );
        }
        
        // Empty state
        if (viewModel.todos.isEmpty) {
          return _EmptyStateWidget();
        }
        
        // Todo list
        return RefreshIndicator(
          onRefresh: viewModel.refresh,
          child: ListView.builder(
            padding: EdgeInsets.all(16),
            itemCount: viewModel.todos.length,
            itemBuilder: (context, index) {
              final todo = viewModel.todos[index];
              return TodoItemWidget(
                key: ValueKey(todo.id),
                todo: todo,
                onToggle: () => viewModel.toggleTodo(todo),
                onDelete: () => _showDeleteDialog(context, todo, viewModel),
              );
            },
          ),
        );
      },
    );
  }
  
  void _showDeleteDialog(BuildContext context, Todo todo, TodoViewModel viewModel) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Delete Todo'),
        content: Text('Are you sure you want to delete "${todo.title}"?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              viewModel.deleteTodo(todo);
            },
            child: Text('Delete', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }
}

// Individual Todo Item Widget
class TodoItemWidget extends StatelessWidget {
  final Todo todo;
  final VoidCallback onToggle;
  final VoidCallback onDelete;
  
  const TodoItemWidget({
    Key? key,
    required this.todo,
    required this.onToggle,
    required this.onDelete,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Card(
      margin: EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: IconButton(
          icon: Icon(
            todo.isCompleted ? Icons.check_circle : Icons.radio_button_unchecked,
            color: todo.isCompleted ? Colors.green : Colors.grey,
          ),
          onPressed: onToggle,
        ),
        title: Text(
          todo.title,
          style: TextStyle(
            decoration: todo.isCompleted ? TextDecoration.lineThrough : null,
            color: todo.isCompleted ? Colors.grey : null,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (todo.description.isNotEmpty) ...[
              Text(todo.description),
              SizedBox(height: 4),
            ],
            Text(
              'Created: ${_formatDate(todo.createdAt)}',
              style: TextStyle(fontSize: 12, color: Colors.grey[600]),
            ),
            if (todo.completedAt != null)
              Text(
                'Completed: ${_formatDate(todo.completedAt!)}',
                style: TextStyle(fontSize: 12, color: Colors.green[600]),
              ),
          ],
        ),
        trailing: IconButton(
          icon: Icon(Icons.delete, color: Colors.red),
          onPressed: onDelete,
        ),
        isThreeLine: todo.description.isNotEmpty,
      ),
    );
  }
  
  String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }
}

// Error Widget
class _ErrorWidget extends StatelessWidget {
  final String error;
  final VoidCallback onRetry;
  
  const _ErrorWidget({
    required this.error,
    required this.onRetry,
  });
  
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error, size: 64, color: Colors.red),
            SizedBox(height: 16),
            Text(
              'Oops! Something went wrong',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Text(
              error,
              textAlign: TextAlign.center,
              style: TextStyle(color: Colors.grey[600]),
            ),
            SizedBox(height: 16),
            ElevatedButton(
              onPressed: onRetry,
              child: Text('Try Again'),
            ),
          ],
        ),
      ),
    );
  }
}

// Empty State Widget
class _EmptyStateWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.inbox, size: 64, color: Colors.grey),
          SizedBox(height: 16),
          Text(
            'No todos yet',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          SizedBox(height: 8),
          Text(
            'Tap the + button to create your first todo',
            style: TextStyle(color: Colors.grey[600]),
          ),
        ],
      ),
    );
  }
}

// Add Todo Button
class _AddTodoButton extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return FloatingActionButton(
      onPressed: () => _showAddTodoDialog(context),
      child: Icon(Icons.add),
    );
  }
  
  void _showAddTodoDialog(BuildContext context) {
    final titleController = TextEditingController();
    final descriptionController = TextEditingController();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Add New Todo'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: titleController,
              decoration: InputDecoration(
                labelText: 'Title',
                border: OutlineInputBorder(),
              ),
              autofocus: true,
            ),
            SizedBox(height: 16),
            TextField(
              controller: descriptionController,
              decoration: InputDecoration(
                labelText: 'Description (optional)',
                border: OutlineInputBorder(),
              ),
              maxLines: 3,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Cancel'),
          ),
          Consumer<TodoViewModel>(
            builder: (context, viewModel, child) {
              return TextButton(
                onPressed: () {
                  final title = titleController.text.trim();
                  if (title.isNotEmpty) {
                    Navigator.pop(context);
                    viewModel.createTodo(title, descriptionController.text.trim());
                  }
                },
                child: Text('Add'),
              );
            },
          ),
        ],
      ),
    );
  }
}
```

### 7. Putting It All Together (main.dart)

```dart
// 🚀 MAIN APP: Brings everything together
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:get_it/get_it.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:http/http.dart' as http;

void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();
  
  print('🚀 Starting Todo App...');
  
  try {
    // Initialize dependencies
    await DependencyInjection.init();
    print('✅ Dependencies initialized');
    
    // Run the app
    runApp(TodoApp());
    
  } catch (e) {
    print('❌ Failed to start app: $e');
    
    // Show error app
    runApp(MaterialApp(
      home: Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error, size: 64, color: Colors.red),
              SizedBox(height: 16),
              Text('Failed to start app'),
              Text('Error: $e'),
            ],
          ),
        ),
      ),
    ));
  }
}

class TodoApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Todo App - MVVM',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: true,
        appBarTheme: AppBarTheme(
          centerTitle: true,
          elevation: 0,
        ),
        cardTheme: CardTheme(
          elevation: 2,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
        ),
        floatingActionButtonTheme: FloatingActionButtonThemeData(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
        ),
      ),
      home: TodoListScreen(),
    );
  }
}
```

## How Everything Works Together

Here's the **data flow** when you create a new todo:

```
1. 📱 USER taps "Add Todo" button in VIEW
   ↓
2. 🧠 VIEW calls viewModel.createTodo()
   ↓
3. 🧠 VIEWMODEL validates data and calls repository.createTodo()
   ↓
4. 📦 REPOSITORY tries API first, then local database if API fails
   ↓
5. 🌐 API SERVICE sends HTTP request to server
   ↓
6. 📦 REPOSITORY saves to local database and cache
   ↓
7. 🧠 VIEWMODEL updates internal state and notifies listeners
   ↓
8. 📱 VIEW automatically rebuilds and shows new todo
```

## Benefits of This Architecture

### ✅ **Separation of Concerns**
- **Views**: Only handle UI
- **ViewModels**: Only handle business logic
- **Repository**: Only handle data management
- **Services**: Only handle data sources

### ✅ **Testability**
```dart
// Easy to test business logic
test('should create todo successfully', () async {
  // Arrange
  final mockRepository = MockTodoRepository();
  final viewModel = TodoViewModel(mockRepository);
  
  // Act
  await viewModel.createTodo('Test Todo', 'Test Description');
  
  // Assert
  expect(viewModel.todos.length, 1);
  expect(viewModel.todos.first.title, 'Test Todo');
});
```

### ✅ **Maintainability**
- Easy to change data sources (API to local database)
- Easy to modify business logic without touching UI
- Easy to update UI without affecting business logic

### ✅ **Scalability**
- Add new features by creating new ViewModels
- Add new data sources by implementing new Services
- Reuse Repository across multiple ViewModels

## Common Mistakes to Avoid

### ❌ **Don't Mix Concerns**
```dart
// BAD: Business logic in UI
class BadTodoScreen extends StatefulWidget {
  void addTodo() {
    // Don't do API calls directly in UI!
    http.post(Uri.parse('api.com/todos'), body: {...});
  }
}
```

### ❌ **Don't Skip the Repository**
```dart
// BAD: ViewModel calling API directly
class BadViewModel extends ChangeNotifier {
  void loadTodos() {
    // Don't call API directly!
    ApiService().getTodos();
  }
}
```

### ❌ **Don't Forget Error Handling**
```dart
// BAD: No error handling
Future<void> loadTodos() async {
  final todos = await repository.getTodos(); // What if this fails?
  _todos = todos;
}
```

## Summary

MVVM Architecture helps you build **clean, maintainable, and testable** Flutter apps by:

1. **📱 VIEW**: Handles UI and user interactions
2. **🧠 VIEWMODEL**: Manages business logic and state
3. **📦 REPOSITORY**: Coordinates data from multiple sources
4. **🌐 SERVICES**: Handle specific data sources (API, Database, Cache)
5. **📊 MODELS**: Define data structures
6. **🔌 DEPENDENCY INJECTION**: Connects everything together

**Think of it like a restaurant:**
- **View** = Menu (what customers see)
- **ViewModel** = Waiter (handles requests and logic)
- **Repository** = Kitchen Manager (coordinates food sources)
- **Services** = Suppliers (provide ingredients)
- **Models** = Recipes (define what dishes look like)
- **DI** = Phone book (helps everyone find each other)

This architecture makes your app **easier to build, test, and maintain** as it grows!